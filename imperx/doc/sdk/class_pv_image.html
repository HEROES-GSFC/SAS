<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>eBUS SDK C++ API: PvImage Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>

	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v3.0.4.2568 C++ API</h2>
		</div>
	</div>
		
		<br>
		<br>

	</body>
	
</html>


<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>PvImage Class Reference</h1><!-- doxytag: class="PvImage" -->
<p>Image interface to a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a>.  
<a href="#_details">More...</a></p>

<p><a href="class_pv_image-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#ae52fc69f9004a60557d2b1c9966a8c76">Alloc</a> (PvUInt32 aSizeX, PvUInt32 aSizeY, PvPixelType aPixelType, PvUInt16 aPaddingX=0, PvUInt16 aPaddingY=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates memory for this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a>.  <a href="#ae52fc69f9004a60557d2b1c9966a8c76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a0d97d25bb65a6552c00023fd2be2e0ca">Attach</a> (void *aRawBuffer, PvUInt32 aSizeX, PvUInt32 aSizeY, PvPixelType aPixelType, PvUInt16 aPaddingX=0, PvUInt16 aPaddingY=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> to an external memory buffer.  <a href="#a0d97d25bb65a6552c00023fd2be2e0ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt8 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a3e2ee3151444da82bb6fa43300190f57">Detach</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases an attached memory buffer.  <a href="#a3e2ee3151444da82bb6fa43300190f57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#ae016c1a96c54cf47cc7bd5c2fbcdfb05">Free</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees (de-allocates) the buffer's internal memory.  <a href="#ae016c1a96c54cf47cc7bd5c2fbcdfb05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a1a2856c064e48109e3ce58dd62b48a0a">GetBitsPerPixel</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns how many bits are required to hold a pixel using the current buffer's pixel type.  <a href="#a1a2856c064e48109e3ce58dd62b48a0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_buffer.html">PvBuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a1f3897e08abb8c6e681ee22f07115cb9">GetBuffer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> belongs to.  <a href="#a1f3897e08abb8c6e681ee22f07115cb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt8 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a5b9de2bc83da76cd75ef2694f9acb28f">GetDataPointer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the buffer's data pointer.  <a href="#a5b9de2bc83da76cd75ef2694f9acb28f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const PvUInt8 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a3d72839d95464a24a8a05cfe59418c42">GetDataPointer</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the buffer's data pointer.  <a href="#a3d72839d95464a24a8a05cfe59418c42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#ac7000be2a297352ef1e29fb4d5518e65">GetEffectiveImageSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Effective image size.  <a href="#ac7000be2a297352ef1e29fb4d5518e65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a6baa291e84982e5452c4b74234c1d10c">GetHeight</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the image's height.  <a href="#a6baa291e84982e5452c4b74234c1d10c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a620e2e080ba699d6b3a334020ac8a2ad">GetImageSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Actual image size within the payload or buffer.  <a href="#a620e2e080ba699d6b3a334020ac8a2ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a0c11016f88340d0f5d88ab672b562db3">GetOffsetX</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the image's horizontal offset.  <a href="#a0c11016f88340d0f5d88ab672b562db3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#aff0bcc003aa400653ca6241f724582a9">GetOffsetY</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the image's vertical offset.  <a href="#aff0bcc003aa400653ca6241f724582a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a72b3b169b4b396c84956547da46935c2">GetPaddingX</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the horizontal image padding.  <a href="#a72b3b169b4b396c84956547da46935c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#ae7d7b4a563de2fbcdf4314714e8d6b6b">GetPaddingY</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the vertical image padding.  <a href="#ae7d7b4a563de2fbcdf4314714e8d6b6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvPixelType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a7f2d56d675f0dd65e983b109b165ba26">GetPixelType</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The buffer's GigE Vision pixel type.  <a href="#a7f2d56d675f0dd65e983b109b165ba26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#aeff3ec4662270cdeef4266d811f9bcd3">GetRequiredSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the size of buffer required to hold the acquired image.  <a href="#aeff3ec4662270cdeef4266d811f9bcd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a9f625bda4f8933b967619d1ff20d3d8f">GetWidth</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the image's width.  <a href="#a9f625bda4f8933b967619d1ff20d3d8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#ad6bf65577c43c8eed78ef60336cbd8d7">IsDataOverrun</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data overrun status bit.  <a href="#ad6bf65577c43c8eed78ef60336cbd8d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#aa5608b83f6224fa83a2e5e999571a9e8">IsEOFByLineCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End of Frame by Line Count status bit.  <a href="#aa5608b83f6224fa83a2e5e999571a9e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a2e1d758e7bf35449eb5f41cacd929e73">IsFullLineMissing</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If true, the grabber (on the device) was missing at least one line when the frame was grabbed.  <a href="#a2e1d758e7bf35449eb5f41cacd929e73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a12d83aab9a0ce7751fd08f285c756ab6">IsImageDropped</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Image dropped status bit.  <a href="#a12d83aab9a0ce7751fd08f285c756ab6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a8718211474c412cabe75039611921018">IsInterlacedEven</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The image contained in the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> is an interlaced Even field.  <a href="#a8718211474c412cabe75039611921018"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#ab7960389da1221f18df7d065f3ced79a">IsInterlacedOdd</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The image contained in the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> is an interlaced Odd field.  <a href="#ab7960389da1221f18df7d065f3ced79a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#ae54ac33c2fa453c0054a544344e7e94a">IsPartialLineMissing</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If true, the grabber (on the device) was missing at least one pixel in at least one of the lines when the frame was grabbed.  <a href="#ae54ac33c2fa453c0054a544344e7e94a"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#ae2bfb527b8144f1e464719c069c743f4">GetPixelSize</a> (PvPixelType aPixelType)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static method returning the pixel size in bits for a specific pixel type.  <a href="#ae2bfb527b8144f1e464719c069c743f4"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#abc9db34b921323fdc18bec63e4a7ae4e">PvImage</a> (PvBufferLib::Image *aImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#abc9db34b921323fdc18bec63e4a7ae4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a3e8bb7b4629973a40fb17923da29c548">~PvImage</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a3e8bb7b4629973a40fb17923da29c548"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Image interface to a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a>. </p>
<p>A <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> represents a generic buffer with no specific payload type. If the payload type is image, the user can obtain a pointer to a <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> buffer interface through <a class="el" href="class_pv_buffer.html#aa0e84f98d2c01c33aa6d58343fc242fc" title="Returns the PvImage interface to the buffer.">PvBuffer::GetImage</a>.</p>
<p>This <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> pointer is owned by the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> and does not need to be released after use. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> exists.</p>
<h2 id="accessing">Accessing image specific data</h2>
<p><b>To determinate the payload type and access image specific data:</b></p>
<ol type="1">
<li>Retrieve the <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f" title="GVSP payload type.">PvPayloadType</a> using <a class="el" href="class_pv_buffer.html#af12443f42dd7cc60f6f158cc0b433122" title="Returns the payload type currently used by the buffer.">PvBuffer::GetPayloadType</a></li>
<li>If <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f" title="GVSP payload type.">PvPayloadType</a> is <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30faeb97a52f2036290b6213951f7782c841">PvPayloadTypeImage</a>, retrieve <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> pointer from your <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a></li>
<li>Access image specific data through the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> pointer, like <a class="el" href="class_pv_image.html#a9f625bda4f8933b967619d1ff20d3d8f" title="Get the image&#39;s width.">PvImage::GetWidth</a>, <a class="el" href="class_pv_image.html#a6baa291e84982e5452c4b74234c1d10c" title="Get the image&#39;s height.">PvImage::GetHeight</a>, etc.</li>
<li>There is no need to release or delete the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> pointer. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> exists. </li>
</ol>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abc9db34b921323fdc18bec63e4a7ae4e"></a><!-- doxytag: member="PvImage::PvImage" ref="abc9db34b921323fdc18bec63e4a7ae4e" args="(PvBufferLib::Image *aImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvImage::PvImage </td>
          <td>(</td>
          <td class="paramtype">PvBufferLib::Image *&nbsp;</td>
          <td class="paramname"> <em>aImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>Declared as protected as <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> cannot be instantiated by the user.</p>
<p>A pointer to the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface can be obtained from a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> using <a class="el" href="class_pv_buffer.html#aa0e84f98d2c01c33aa6d58343fc242fc" title="Returns the PvImage interface to the buffer.">PvBuffer::GetImage</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aImage</em>&nbsp;</td><td>Pointer to internal PureGEV class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e8bb7b4629973a40fb17923da29c548"></a><!-- doxytag: member="PvImage::~PvImage" ref="a3e8bb7b4629973a40fb17923da29c548" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvImage::~PvImage </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>Declared as protected as the user does no need (or can) delete a <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> directly. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae52fc69f9004a60557d2b1c9966a8c76"></a><!-- doxytag: member="PvImage::Alloc" ref="ae52fc69f9004a60557d2b1c9966a8c76" args="(PvUInt32 aSizeX, PvUInt32 aSizeY, PvPixelType aPixelType, PvUInt16 aPaddingX=0, PvUInt16 aPaddingY=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvImage::Alloc </td>
          <td>(</td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aSizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aSizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvPixelType&nbsp;</td>
          <td class="paramname"> <em>aPixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt16&nbsp;</td>
          <td class="paramname"> <em>aPaddingX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt16&nbsp;</td>
          <td class="paramname"> <em>aPaddingY</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates memory for this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a>. </p>
<p>Allocs a <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> of specific width, height and pixel format</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aSizeX</em>&nbsp;</td><td>The width of the image, in pixels. See <a class="el" href="class_pv_image.html#a9f625bda4f8933b967619d1ff20d3d8f" title="Get the image&#39;s width.">GetWidth</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aSizeY</em>&nbsp;</td><td>The height of the image, in pixels. See <a class="el" href="class_pv_image.html#a6baa291e84982e5452c4b74234c1d10c" title="Get the image&#39;s height.">GetHeight</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPixelType</em>&nbsp;</td><td>The GEV pixel type from which the pixel depth is extracted. For supported pixel types, see <a class="el" href="_pv_pixel_type_8h_source.html">PvPixelType.h</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPaddingX</em>&nbsp;</td><td>The horizontal padding of the image, in pixels. See <a class="el" href="class_pv_image.html#a72b3b169b4b396c84956547da46935c2" title="Get the horizontal image padding.">GetPaddingX</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPaddingY</em>&nbsp;</td><td>The vertical padding of the image, in pixels. See <a class="el" href="class_pv_image.html#ae7d7b4a563de2fbcdf4314714e8d6b6b" title="Get the vertical image padding.">GetPaddingY</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af3b30f8e00bd6032aa0006d5aff5f606" title="Not enough memory.">PvResult::Code::NOT_ENOUGH_MEMORY</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0d97d25bb65a6552c00023fd2be2e0ca"></a><!-- doxytag: member="PvImage::Attach" ref="a0d97d25bb65a6552c00023fd2be2e0ca" args="(void *aRawBuffer, PvUInt32 aSizeX, PvUInt32 aSizeY, PvPixelType aPixelType, PvUInt16 aPaddingX=0, PvUInt16 aPaddingY=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvImage::Attach </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aRawBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aSizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aSizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvPixelType&nbsp;</td>
          <td class="paramname"> <em>aPixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt16&nbsp;</td>
          <td class="paramname"> <em>aPaddingX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt16&nbsp;</td>
          <td class="paramname"> <em>aPaddingY</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attach this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> to an external memory buffer. </p>
<p>This method is identical to <a class="el" href="class_pv_image.html#ae52fc69f9004a60557d2b1c9966a8c76" title="Allocates memory for this PvImage.">Alloc(PvUInt32,PvUInt32,PvPixelType,PvUInt16,PvUInt16)</a>, with the following exceptions:</p>
<ul>
<li>This method uses an external memory buffer, controlled by the caller.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aRawBuffer</em>&nbsp;</td><td>A pointer to the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aSizeX</em>&nbsp;</td><td>See <a class="el" href="class_pv_image.html#ae52fc69f9004a60557d2b1c9966a8c76" title="Allocates memory for this PvImage.">Alloc(PvUInt32,PvUInt32,PvPixelType,PvUInt16,PvUInt16)</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aSizeY</em>&nbsp;</td><td>See <a class="el" href="class_pv_image.html#ae52fc69f9004a60557d2b1c9966a8c76" title="Allocates memory for this PvImage.">Alloc(PvUInt32,PvUInt32,PvPixelType,PvUInt16,PvUInt16)</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPixelType</em>&nbsp;</td><td>See <a class="el" href="class_pv_image.html#ae52fc69f9004a60557d2b1c9966a8c76" title="Allocates memory for this PvImage.">Alloc(PvUInt32,PvUInt32,PvPixelType,PvUInt16,PvUInt16)</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPaddingX</em>&nbsp;</td><td>See <a class="el" href="class_pv_image.html#ae52fc69f9004a60557d2b1c9966a8c76" title="Allocates memory for this PvImage.">Alloc(PvUInt32,PvUInt32,PvPixelType,PvUInt16,PvUInt16)</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPaddingY</em>&nbsp;</td><td>See <a class="el" href="class_pv_image.html#ae52fc69f9004a60557d2b1c9966a8c76" title="Allocates memory for this PvImage.">Alloc(PvUInt32,PvUInt32,PvPixelType,PvUInt16,PvUInt16)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a1fc2ef16100f16a44da2df392d010871" title="A parameter passed to the method is invalid.">PvResult::Code::INVALID_PARAMETER</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3e2ee3151444da82bb6fa43300190f57"></a><!-- doxytag: member="PvImage::Detach" ref="a3e2ee3151444da82bb6fa43300190f57" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt8 * PvImage::Detach </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases an attached memory buffer. </p>
<p>Does nothing other then resetting the memory buffer pointer to NULL.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The buffer's location in memory.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_pv_image.html#a0d97d25bb65a6552c00023fd2be2e0ca" title="Attach this PvImage to an external memory buffer.">Attach</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae016c1a96c54cf47cc7bd5c2fbcdfb05"></a><!-- doxytag: member="PvImage::Free" ref="ae016c1a96c54cf47cc7bd5c2fbcdfb05" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PvImage::Free </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees (de-allocates) the buffer's internal memory. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_pv_image.html#ae52fc69f9004a60557d2b1c9966a8c76" title="Allocates memory for this PvImage.">Alloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1a2856c064e48109e3ce58dd62b48a0a"></a><!-- doxytag: member="PvImage::GetBitsPerPixel" ref="a1a2856c064e48109e3ce58dd62b48a0a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvImage::GetBitsPerPixel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns how many bits are required to hold a pixel using the current buffer's pixel type. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Bits per pixel for the current buffer's pixel type. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f3897e08abb8c6e681ee22f07115cb9"></a><!-- doxytag: member="PvImage::GetBuffer" ref="a1f3897e08abb8c6e681ee22f07115cb9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_buffer.html">PvBuffer</a> * PvImage::GetBuffer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> belongs to. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b9de2bc83da76cd75ef2694f9acb28f"></a><!-- doxytag: member="PvImage::GetDataPointer" ref="a5b9de2bc83da76cd75ef2694f9acb28f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt8 * PvImage::GetDataPointer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the buffer's data pointer. </p>
<p>Const version.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the memory pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d72839d95464a24a8a05cfe59418c42"></a><!-- doxytag: member="PvImage::GetDataPointer" ref="a3d72839d95464a24a8a05cfe59418c42" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const PvUInt8 * PvImage::GetDataPointer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the buffer's data pointer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the memory pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7000be2a297352ef1e29fb4d5518e65"></a><!-- doxytag: member="PvImage::GetEffectiveImageSize" ref="ac7000be2a297352ef1e29fb4d5518e65" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvImage::GetEffectiveImageSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Effective image size. </p>
<p>Uses same size x and y as <a class="el" href="class_pv_image.html#a620e2e080ba699d6b3a334020ac8a2ad" title="Actual image size within the payload or buffer.">GetImageSize()</a> but excludes all padding.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The effective image size </dd></dl>

</div>
</div>
<a class="anchor" id="a6baa291e84982e5452c4b74234c1d10c"></a><!-- doxytag: member="PvImage::GetHeight" ref="a6baa291e84982e5452c4b74234c1d10c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvImage::GetHeight </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the image's height. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The image's height, in pixels. </dd></dl>

</div>
</div>
<a class="anchor" id="a620e2e080ba699d6b3a334020ac8a2ad"></a><!-- doxytag: member="PvImage::GetImageSize" ref="a620e2e080ba699d6b3a334020ac8a2ad" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvImage::GetImageSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Actual image size within the payload or buffer. </p>
<p>Uses the GEV leader for the actual width. Uses the GEV trailer for line count which is the actual height.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The actual image size within the payload or buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a0c11016f88340d0f5d88ab672b562db3"></a><!-- doxytag: member="PvImage::GetOffsetX" ref="a0c11016f88340d0f5d88ab672b562db3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvImage::GetOffsetX </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the image's horizontal offset. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The image's horizontal offset, in pixels. </dd></dl>

</div>
</div>
<a class="anchor" id="aff0bcc003aa400653ca6241f724582a9"></a><!-- doxytag: member="PvImage::GetOffsetY" ref="aff0bcc003aa400653ca6241f724582a9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvImage::GetOffsetY </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the image's vertical offset. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The image's vertical offset, in pixels. </dd></dl>

</div>
</div>
<a class="anchor" id="a72b3b169b4b396c84956547da46935c2"></a><!-- doxytag: member="PvImage::GetPaddingX" ref="a72b3b169b4b396c84956547da46935c2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt16 PvImage::GetPaddingX </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the horizontal image padding. </p>
<p>Images lines could be grabbed in increments of, let's say, 32 bytes. For an image 511 bytes across, the IP Engine adds a meaningless byte to make the line total 512 bytes (divisible by 32). In this case, the <em>paddingX</em> value would be 1 (byte).</p>
<p>Other GigE Vision devices may have different requirements on line length. Divible by 4, 8, 16, etc. or no specific limitations or requirements.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The horizontal image padding, in bytes; the number of bytes at the end of an image's line that contain meaningless data. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7d7b4a563de2fbcdf4314714e8d6b6b"></a><!-- doxytag: member="PvImage::GetPaddingY" ref="ae7d7b4a563de2fbcdf4314714e8d6b6b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt16 PvImage::GetPaddingY </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the vertical image padding. </p>
<p>Additional bytes appended at the end of an image.</p>
<p>See <a class="el" href="class_pv_image.html#a72b3b169b4b396c84956547da46935c2" title="Get the horizontal image padding.">GetPaddingX</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The vertical image padding, in bytes.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_pv_image.html#a72b3b169b4b396c84956547da46935c2" title="Get the horizontal image padding.">GetPaddingX</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae2bfb527b8144f1e464719c069c743f4"></a><!-- doxytag: member="PvImage::GetPixelSize" ref="ae2bfb527b8144f1e464719c069c743f4" args="(PvPixelType aPixelType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvImage::GetPixelSize </td>
          <td>(</td>
          <td class="paramtype">PvPixelType&nbsp;</td>
          <td class="paramname"> <em>aPixelType</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Static method returning the pixel size in bits for a specific pixel type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPixelType</em>&nbsp;</td><td>Pixel type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pixel size, in bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f2d56d675f0dd65e983b109b165ba26"></a><!-- doxytag: member="PvImage::GetPixelType" ref="a7f2d56d675f0dd65e983b109b165ba26" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvPixelType PvImage::GetPixelType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The buffer's GigE Vision pixel type. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The GigE Vision pixel type. The pixel depth, colorspace, and other information are coded into the value. </dd></dl>

</div>
</div>
<a class="anchor" id="aeff3ec4662270cdeef4266d811f9bcd3"></a><!-- doxytag: member="PvImage::GetRequiredSize" ref="aeff3ec4662270cdeef4266d811f9bcd3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvImage::GetRequiredSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of buffer required to hold the acquired image. </p>
<p>This attribute is valid if the last image acquisition was successful or if it failed because the buffer was too small. It can be used to re-allocate the acquisition buffers if the acquisition failed because the buffer was too small.</p>
<p>The required size is only computed for the last image - based on the number of lines as provided in the GigE Vision streaming protocol trailer.</p>
<p>It is possible that with devices outputting images of varying length (like line scan cameras) that the last image required size may be smaller than the maximum possible size.</p>
<p>In order to be 100% sure of allocating buffers correctly, you should either hard code the buffer size to known big enough sizes or use the device GenICam GevPayloadSize parameter for dynamic cases.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The size, in bytes, required to hold the image in this buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f625bda4f8933b967619d1ff20d3d8f"></a><!-- doxytag: member="PvImage::GetWidth" ref="a9f625bda4f8933b967619d1ff20d3d8f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvImage::GetWidth </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the image's width. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The image's width in pixels. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6bf65577c43c8eed78ef60336cbd8d7"></a><!-- doxytag: member="PvImage::IsDataOverrun" ref="ad6bf65577c43c8eed78ef60336cbd8d7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsDataOverrun </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Data overrun status bit. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if there was a data overrun. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5608b83f6224fa83a2e5e999571a9e8"></a><!-- doxytag: member="PvImage::IsEOFByLineCount" ref="aa5608b83f6224fa83a2e5e999571a9e8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsEOFByLineCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>End of Frame by Line Count status bit. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if previous frame was NOT the last one of a sequence of sub frames. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e1d758e7bf35449eb5f41cacd929e73"></a><!-- doxytag: member="PvImage::IsFullLineMissing" ref="a2e1d758e7bf35449eb5f41cacd929e73" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsFullLineMissing </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If true, the grabber (on the device) was missing at least one line when the frame was grabbed. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if full lines were missing, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a12d83aab9a0ce7751fd08f285c756ab6"></a><!-- doxytag: member="PvImage::IsImageDropped" ref="a12d83aab9a0ce7751fd08f285c756ab6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsImageDropped </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Image dropped status bit. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the previous frame was dropped. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8718211474c412cabe75039611921018"></a><!-- doxytag: member="PvImage::IsInterlacedEven" ref="a8718211474c412cabe75039611921018" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsInterlacedEven </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The image contained in the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> is an interlaced Even field. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True interlaced Even field. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7960389da1221f18df7d065f3ced79a"></a><!-- doxytag: member="PvImage::IsInterlacedOdd" ref="ab7960389da1221f18df7d065f3ced79a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsInterlacedOdd </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The image contained in the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> is an interlaced Odd field. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True interlaced Odd field. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae54ac33c2fa453c0054a544344e7e94a"></a><!-- doxytag: member="PvImage::IsPartialLineMissing" ref="ae54ac33c2fa453c0054a544344e7e94a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsPartialLineMissing </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If true, the grabber (on the device) was missing at least one pixel in at least one of the lines when the frame was grabbed. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if at least one pixel was missing, false otherwise </dd></dl>

</div>
</div>
</div>
<hr size="1">
<P><B>Copyright (c) 2002-2012 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>

