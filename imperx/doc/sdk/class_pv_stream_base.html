<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>eBUS SDK C++ API: PvStreamBase Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>

	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v3.0.4.2568 C++ API</h2>
		</div>
	</div>
		
		<br>
		<br>

	</body>
	
</html>


<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>PvStreamBase Class Reference</h1><!-- doxytag: class="PvStreamBase" -->
<p>Base class defining functionality inherited by <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision transmitter (data receiver properties dynamically...">PvStream</a> and <a class="el" href="class_pv_stream_raw.html" title="Receive data from a GigE Vision transmitter (data receiver properties accessible...">PvStreamRaw</a>.  
<a href="#_details">More...</a></p>
<div class="dynheader">
Inheritance diagram for PvStreamBase:</div>
<div class="dynsection">
 <div class="center">
  <img src="class_pv_stream_base.gif" usemap="#PvStreamBase_map" alt=""/>
  <map id="PvStreamBase_map" name="PvStreamBase_map">
<area href="class_pv_stream.html" alt="PvStream" shape="rect" coords="0,56,94,80"/>
<area href="class_pv_stream_raw.html" alt="PvStreamRaw" shape="rect" coords="104,56,198,80"/>
</map>
 </div>
</div>

<p><a href="class_pv_stream_base-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#a40e2bd6c9a7e954abdb3baff26db62c1">AbortQueuedBuffers</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abort all pending block requests.  <a href="#a40e2bd6c9a7e954abdb3baff26db62c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#a2742f5a2aab2f97c49fbfbe43ba4a248">Close</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the stream channel receiver.  <a href="#a2742f5a2aab2f97c49fbfbe43ba4a248"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#ae3905226cf694d4d484e1742c9eba543">FlushPacketQueue</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flushes all non-processed UDP packets from the data receiver.  <a href="#ae3905226cf694d4d484e1742c9eba543"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#a8e3b3db730d2dfc6f4ea9211db36fe4b">GetChannelID</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_string.html">PvString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#a159d2d68dcc8970c11fdb6ebada7ba2f">GetLocalIPAddress</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the stream's <a href="streamparameters.html#LocalIPAddress">LocalIPAddress</a> property.  <a href="#a159d2d68dcc8970c11fdb6ebada7ba2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#a7bfe1b9a25c3d893a8df7ef422d1d46e">GetLocalPort</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the stream's <a href="streamparameters.html#DataPort">DataPort</a> property.  <a href="#a7bfe1b9a25c3d893a8df7ef422d1d46e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_string.html">PvString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#a2ac37e3b782b89312c1af48daeba3b35">GetMulticastIPAddress</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the stream's <a href="streamparameters.html#MulticastIPAddress">MulticastIPAddress</a> property.  <a href="#a2ac37e3b782b89312c1af48daeba3b35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#aa36e969cd15aef1f543dbacce812aa5f">GetQueuedBufferCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of buffers (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> objects) waiting to be filled with images by the data receiver.  <a href="#aa36e969cd15aef1f543dbacce812aa5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#a0997241d2e81ffd0c2799ebf8b4034cc">GetQueuedBufferMaximum</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximum number of buffers (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> objects) that can be queued at a time.  <a href="#a0997241d2e81ffd0c2799ebf8b4034cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#a43efae0ca2e8805e68d69e9390754b20">GetUserModeDataReceiverThreadPriority</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the priority of the thread used to run the data receiver user mode.  <a href="#a43efae0ca2e8805e68d69e9390754b20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#ad8cbbcbed57580e0120501f2078c2509">IsOpen</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the stream is open.  <a href="#ad8cbbcbed57580e0120501f2078c2509"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#a7f635754599cf744b617d40cb0799ae1">Open</a> (const <a class="el" href="class_pv_string.html">PvString</a> &amp;aIPAddress, const <a class="el" href="class_pv_string.html">PvString</a> &amp;aMulticastAddr, PvUInt16 aDataPort, PvUInt16 aChannelID=0, const <a class="el" href="class_pv_string.html">PvString</a> &amp;aLocalIPAddress=<a class="el" href="class_pv_string.html">PvString</a>(), PvUInt32 aBuffersCapacity=64)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin receiving blocks (images or raw data) <b>multicasted</b> from a GigE Vision transmitter.  <a href="#a7f635754599cf744b617d40cb0799ae1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#a6566ab11aae4d630ea0888e7909c7b31">Open</a> (const <a class="el" href="class_pv_string.html">PvString</a> &amp;aIPAddress, PvUInt16 aLocalPort=0, PvUInt16 aChannelID=0, const <a class="el" href="class_pv_string.html">PvString</a> &amp;aLocalIpAddress=<a class="el" href="class_pv_string.html">PvString</a>(), PvUInt32 aBuffersCapacity=64)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin receiving blocks (images or raw data) <b>unicasted</b> from a GigE Vision transmitter.  <a href="#a6566ab11aae4d630ea0888e7909c7b31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#adc26906a207c0ff5a44fa2ae0876ff1f">QueueBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> *aBuffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue a buffer to receive a block.  <a href="#adc26906a207c0ff5a44fa2ae0876ff1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#a17488b8b84e1522730452628a968e38e">RegisterEventSink</a> (<a class="el" href="class_pv_stream_base_event_sink.html">PvStreamBaseEventSink</a> *aEventSink)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register an event sink used for callbacks.  <a href="#a17488b8b84e1522730452628a968e38e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#a3f53879cb4411d122757c99c73e67e3d">RetrieveBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> **aBuffer, <a class="el" href="class_pv_result.html">PvResult</a> *aOperationResult, PvUInt32 aTimeout=0xFFFFFFFF)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to retrieve a queued buffer.  <a href="#a3f53879cb4411d122757c99c73e67e3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#ae8d0a1ebcb370242ce2b5a99abc32fbc">SetUserModeDataReceiverThreadPriority</a> (PvUInt32 aPriority)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the priority of the thread used to run the data receiver user mode.  <a href="#ae8d0a1ebcb370242ce2b5a99abc32fbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#a05d76895d0f8ecf86500e30098297510">UnregisterEventSink</a> (<a class="el" href="class_pv_stream_base_event_sink.html">PvStreamBaseEventSink</a> *aEventSink)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister an event sink.  <a href="#a05d76895d0f8ecf86500e30098297510"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#af7257223cf8bd9b09e7b08a1e1365ca0">IsDriverInstalled</a> (<a class="el" href="class_pv_string.html">PvString</a> &amp;aIPAddress, bool &amp;aInstalled, const <a class="el" href="class_pv_string.html">PvString</a> &amp;aLocalIPAddress=<a class="el" href="class_pv_string.html">PvString</a>())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the specified GigE Vision device is currently reachable through an eBUS driver.  <a href="#af7257223cf8bd9b09e7b08a1e1365ca0"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#a80ded7fbd807edbe5c93f275f8a0ccf9">PvStreamBase</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a80ded7fbd807edbe5c93f275f8a0ccf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#a5896792a44f4a0d4abccfcd444fea3b6">~PvStreamBase</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a5896792a44f4a0d4abccfcd444fea3b6"></a><br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a304b6733d7b057c958e051fcea83789c"></a><!-- doxytag: member="PvStreamBase::PvConfigurationReader" ref="a304b6733d7b057c958e051fcea83789c" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#a304b6733d7b057c958e051fcea83789c">PvConfigurationReader</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac517f739d9d345b2cb5f6bfdf7ad9aa3"></a><!-- doxytag: member="PvStreamBase::PvConfigurationWriter" ref="ac517f739d9d345b2cb5f6bfdf7ad9aa3" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#ac517f739d9d345b2cb5f6bfdf7ad9aa3">PvConfigurationWriter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbebe17463fe09a03e19c5ac67193db8"></a><!-- doxytag: member="PvStreamBase::PvPipeline" ref="afbebe17463fe09a03e19c5ac67193db8" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream_base.html#afbebe17463fe09a03e19c5ac67193db8">PvPipeline</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Base class defining functionality inherited by <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision transmitter (data receiver properties dynamically...">PvStream</a> and <a class="el" href="class_pv_stream_raw.html" title="Receive data from a GigE Vision transmitter (data receiver properties accessible...">PvStreamRaw</a>. </p>
<p>You cannot instantiate a <a class="el" href="class_pv_stream_base.html" title="Base class defining functionality inherited by PvStream and PvStreamRaw.">PvStreamBase</a> directly - its functionality is inherited when a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision transmitter (data receiver properties dynamically...">PvStream</a> or <a class="el" href="class_pv_stream_raw.html" title="Receive data from a GigE Vision transmitter (data receiver properties accessible...">PvStreamRaw</a> object is instantiated. For further information on how <a class="el" href="class_pv_stream_base.html" title="Base class defining functionality inherited by PvStream and PvStreamRaw.">PvStreamBase</a> fits in with the process of receiving data from a GigE Vision transmitter, refer to the page entitled <a href="receivingdata.html">Receiving Data from a GigE Vision Transmitter</a>. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a80ded7fbd807edbe5c93f275f8a0ccf9"></a><!-- doxytag: member="PvStreamBase::PvStreamBase" ref="a80ded7fbd807edbe5c93f275f8a0ccf9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvStreamBase::PvStreamBase </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="a5896792a44f4a0d4abccfcd444fea3b6"></a><!-- doxytag: member="PvStreamBase::~PvStreamBase" ref="a5896792a44f4a0d4abccfcd444fea3b6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvStreamBase::~PvStreamBase </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a40e2bd6c9a7e954abdb3baff26db62c1"></a><!-- doxytag: member="PvStreamBase::AbortQueuedBuffers" ref="a40e2bd6c9a7e954abdb3baff26db62c1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamBase::AbortQueuedBuffers </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abort all pending block requests. </p>
<p>Once you've aborted pending block requests, they still need to be de-queued. Use <a class="el" href="class_pv_stream_base.html#a3f53879cb4411d122757c99c73e67e3d" title="Attempt to retrieve a queued buffer.">RetrieveBuffer</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a> (Always succeeds.) </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a2742f5a2aab2f97c49fbfbe43ba4a248"></a><!-- doxytag: member="PvStreamBase::Close" ref="a2742f5a2aab2f97c49fbfbe43ba4a248" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamBase::Close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close the stream channel receiver. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a></li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_pv_stream_base.html#a6566ab11aae4d630ea0888e7909c7b31" title="Begin receiving blocks (images or raw data) unicasted from a GigE Vision transmitter...">Open</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae3905226cf694d4d484e1742c9eba543"></a><!-- doxytag: member="PvStreamBase::FlushPacketQueue" ref="ae3905226cf694d4d484e1742c9eba543" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamBase::FlushPacketQueue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flushes all non-processed UDP packets from the data receiver. </p>
<p>Should be called before resuming streaming after a pause to ensure that old packets are not processed as new incoming data.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8e3b3db730d2dfc6f4ea9211db36fe4b"></a><!-- doxytag: member="PvStreamBase::GetChannelID" ref="a8e3b3db730d2dfc6f4ea9211db36fe4b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt16 PvStreamBase::GetChannelID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>\ brief Get the stream's ChannelID property.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The stream's ChannelID property. </dd></dl>

</div>
</div>
<a class="anchor" id="a159d2d68dcc8970c11fdb6ebada7ba2f"></a><!-- doxytag: member="PvStreamBase::GetLocalIPAddress" ref="a159d2d68dcc8970c11fdb6ebada7ba2f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_string.html">PvString</a> PvStreamBase::GetLocalIPAddress </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the stream's <a href="streamparameters.html#LocalIPAddress">LocalIPAddress</a> property. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The stream's <a href="streamparameters.html#LocalIPAddress">LocalIPAddress</a> property. </dd></dl>

</div>
</div>
<a class="anchor" id="a7bfe1b9a25c3d893a8df7ef422d1d46e"></a><!-- doxytag: member="PvStreamBase::GetLocalPort" ref="a7bfe1b9a25c3d893a8df7ef422d1d46e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt16 PvStreamBase::GetLocalPort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the stream's <a href="streamparameters.html#DataPort">DataPort</a> property. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The stream's <a href="streamparameters.html#DataPort">DataPort</a> property. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ac37e3b782b89312c1af48daeba3b35"></a><!-- doxytag: member="PvStreamBase::GetMulticastIPAddress" ref="a2ac37e3b782b89312c1af48daeba3b35" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_string.html">PvString</a> PvStreamBase::GetMulticastIPAddress </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the stream's <a href="streamparameters.html#MulticastIPAddress">MulticastIPAddress</a> property. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The stream's <a href="streamparameters.html#MulticastIPAddress">MulticastIPAddress</a> property. </dd></dl>

</div>
</div>
<a class="anchor" id="aa36e969cd15aef1f543dbacce812aa5f"></a><!-- doxytag: member="PvStreamBase::GetQueuedBufferCount" ref="aa36e969cd15aef1f543dbacce812aa5f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvStreamBase::GetQueuedBufferCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of buffers (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> objects) waiting to be filled with images by the data receiver. </p>
<p>Every call to <a class="el" href="class_pv_stream_base.html#adc26906a207c0ff5a44fa2ae0876ff1f" title="Queue a buffer to receive a block.">QueueBuffer</a> increases the count by one; every call to <a class="el" href="class_pv_stream_base.html#a3f53879cb4411d122757c99c73e67e3d" title="Attempt to retrieve a queued buffer.">RetrieveBuffer</a> reduces the count by one.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of buffers (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> objects). </dd></dl>

</div>
</div>
<a class="anchor" id="a0997241d2e81ffd0c2799ebf8b4034cc"></a><!-- doxytag: member="PvStreamBase::GetQueuedBufferMaximum" ref="a0997241d2e81ffd0c2799ebf8b4034cc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvStreamBase::GetQueuedBufferMaximum </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the maximum number of buffers (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> objects) that can be queued at a time. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Maximum number of buffers (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> objects). </dd></dl>

</div>
</div>
<a class="anchor" id="a43efae0ca2e8805e68d69e9390754b20"></a><!-- doxytag: member="PvStreamBase::GetUserModeDataReceiverThreadPriority" ref="a43efae0ca2e8805e68d69e9390754b20" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvStreamBase::GetUserModeDataReceiverThreadPriority </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the priority of the thread used to run the data receiver user mode. </p>
<p>See <a class="el" href="class_pv_stream_base.html#ae8d0a1ebcb370242ce2b5a99abc32fbc" title="Set the priority of the thread used to run the data receiver user mode.">SetUserModeDataReceiverThreadPriority</a> for details about the meaning of the values returned</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The priority of the thread </dd></dl>

</div>
</div>
<a class="anchor" id="af7257223cf8bd9b09e7b08a1e1365ca0"></a><!-- doxytag: member="PvStreamBase::IsDriverInstalled" ref="af7257223cf8bd9b09e7b08a1e1365ca0" args="(PvString &amp;aIPAddress, bool &amp;aInstalled, const PvString &amp;aLocalIPAddress=PvString())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamBase::IsDriverInstalled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_string.html">PvString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aIPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>aInstalled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_pv_string.html">PvString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aLocalIPAddress</em> = <code><a class="el" href="class_pv_string.html">PvString</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the specified GigE Vision device is currently reachable through an eBUS driver. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>For legacy eBUS drivers (such as eBUS Optimal and the old eBUS Universal driver), an extra plug-and-play step is required when receiving data from a given device for the first time. This extra step takes some time to complete and occurs when <a class="el" href="class_pv_stream_base.html#a6566ab11aae4d630ea0888e7909c7b31" title="Begin receiving blocks (images or raw data) unicasted from a GigE Vision transmitter...">Open</a> is called for the first time. Prior to this, <a class="el" href="class_pv_stream_base.html#af7257223cf8bd9b09e7b08a1e1365ca0" title="Test if the specified GigE Vision device is currently reachable through an eBUS driver...">IsDriverInstalled</a> returns false because that step has not yet been performed.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aIPAddress</em>&nbsp;</td><td>The GigE Vision transmitter's IP address. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>aInstalled</em>&nbsp;</td><td>True if the device is reachable through an eBUS driver; otherwise, false. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aLocalIPAddress</em>&nbsp;</td><td>Local IP address the device will be streaming to. Optional, can improve <a class="el" href="class_pv_stream_base.html#af7257223cf8bd9b09e7b08a1e1365ca0" title="Test if the specified GigE Vision device is currently reachable through an eBUS driver...">IsDriverInstalled</a> method performance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a1fc2ef16100f16a44da2df392d010871" title="A parameter passed to the method is invalid.">PvResult::Code::INVALID_PARAMETER</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad8cbbcbed57580e0120501f2078c2509"></a><!-- doxytag: member="PvStreamBase::IsOpen" ref="ad8cbbcbed57580e0120501f2078c2509" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvStreamBase::IsOpen </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the stream is open. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the <a class="el" href="class_pv_stream_base.html#a6566ab11aae4d630ea0888e7909c7b31" title="Begin receiving blocks (images or raw data) unicasted from a GigE Vision transmitter...">Open</a> method has been called (without a subsquent <a class="el" href="class_pv_stream_base.html#a2742f5a2aab2f97c49fbfbe43ba4a248" title="Close the stream channel receiver.">Close</a> call); otherwise, false. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f635754599cf744b617d40cb0799ae1"></a><!-- doxytag: member="PvStreamBase::Open" ref="a7f635754599cf744b617d40cb0799ae1" args="(const PvString &amp;aIPAddress, const PvString &amp;aMulticastAddr, PvUInt16 aDataPort, PvUInt16 aChannelID=0, const PvString &amp;aLocalIPAddress=PvString(), PvUInt32 aBuffersCapacity=64)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamBase::Open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pv_string.html">PvString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aIPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_pv_string.html">PvString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aMulticastAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt16&nbsp;</td>
          <td class="paramname"> <em>aDataPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt16&nbsp;</td>
          <td class="paramname"> <em>aChannelID</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_pv_string.html">PvString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aLocalIPAddress</em> = <code><a class="el" href="class_pv_string.html">PvString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aBuffersCapacity</em> = <code>64</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begin receiving blocks (images or raw data) <b>multicasted</b> from a GigE Vision transmitter. </p>
<p>Note that this overload of Open is for receiving blocks that are multicasted from a GigE Vision transmitter to a given multicast group. To receive unicasted data, refer to the other overload of the Open method (PvStreamBase::Open(const PvString&amp;,PvUInt16,PvUInt16,const PvString&amp;)).</p>
<p>Multicasting is the delivery of data to a group of receivers simultaneously in a single transmission.</p>
<p>The following example illustrates how to multicast data from one transmitter to a given set of receivers:</p>
<ul>
<li>Connect receivers and transmitter to an IGMP compliant switch.</li>
<li>The GigE Vision transmitter begins transmitting to a multicast group (i.e. 239.192.1.1:1042).</li>
<li>The GigE Vision transmitter has a control channel listening for device discovery requests and packet resend requests on a given IP address (i.e. 169.254.1.1).</li>
<li>Receiver applications discover the device and subscribe to the multicast group (call <b>Open( "169.254.1.1", "239.192.1.1", 1042 )</b>)</li>
</ul>
<p>Why does the GigE Vision device address (<em>aIPAddress</em>) need to be specified? In this example, the data is transmitted using the GVSP protocol to a multicast group (239.192.1.1:1042). The receiving application contacts the device (IP address 169.254.1.1) using the GVCP protocol to ensure that it is reachable. In addition to this, packet resend requests are directed from receiver to GigE Vision device using the GVCP control channel. This is by design as per the GigEVision standard.</p>
<p>Multicasting uses the IGMP (Internet Group Management Protocol) and requires an IGMP-compliant switch. The switch maintains a list of subscribed peers associated with a given multicast group. Multicast group IP addresses take the form <code>239.192.<em>xx</em>.<em>yy</em></code>. It is also possible to use multicasting with a non-IGMP compliant switch or network. In that case, the multicast stream is simply broadcasted to every connected entity on the network. It can be OK in controlled environment, but use with caution! To learn more about IGMPv3, see <em>RFC 3376</em> at www.ietf.org.</p>
<p>For a complete illustration of how to use this method to receive data multicasted from a GigE Vision transmitter, refer to the following two samples:</p>
<ul>
<li>PvMulticastMasterSample - Connects to a GigE Vision device as a controler and tells it to begin streaming to a multicast address.</li>
<li>PvMulticastSlaveSample - Illustrates the use of PvStreamBase::Open(const PvString &amp; aIpAddress,const PvString &amp;,PvUInt16,PvUInt16,const PvString &amp;) by receiving the data the GigE Vision device is transmitting.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aIPAddress</em>&nbsp;</td><td>The GigE Vision transmitter's IP address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aMulticastAddr</em>&nbsp;</td><td>The multicast IP address to which the receiver subscribes and the GigE Vision transmitter sends data. (Set the streaming channel destination address (SCDA) on your GigE Vision transmitter accordingly by calling <a class="el" href="class_pv_device.html#ae8a7d5bbd04c8c73b639117768e37061" title="Set the UDP/IP destination to which the GigE Vision device transmits data.">PvDevice::SetStreamDestination</a>.) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aDataPort</em>&nbsp;</td><td>The multicast port to which the receiver subscribes and the GigE Vision transmitter sends data. (Set the streaming channel port (SCP) on your GigE Vision transmitter accordingly by calling <a class="el" href="class_pv_device.html#ae8a7d5bbd04c8c73b639117768e37061" title="Set the UDP/IP destination to which the GigE Vision device transmits data.">PvDevice::SetStreamDestination</a>.) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aChannelID</em>&nbsp;</td><td>The GigE Vision transmitter's streaming channel (default 0). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aLocalIPAddress</em>&nbsp;</td><td>The local IP address upon which the stream object will begin receiving incoming data. An empty string (default) indicates that the local ip address will be assigned automatically. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aBuffersCapacity</em>&nbsp;</td><td>The maximum number of buffers that can be stored simultaneously in the data receiver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#ac9f683e6f2d696181b220cfd893e0482" title="The object (PvDevice or PvStream object) isn&#39;t connected.">PvResult::Code::NOT_CONNECTED</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a09821ccee069f171e970e1904b5ebdf8" title="An undefined error occurred.">PvResult::Code::GENERIC_ERROR</a></li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_pv_stream_base.html#a2742f5a2aab2f97c49fbfbe43ba4a248" title="Close the stream channel receiver.">Close</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6566ab11aae4d630ea0888e7909c7b31"></a><!-- doxytag: member="PvStreamBase::Open" ref="a6566ab11aae4d630ea0888e7909c7b31" args="(const PvString &amp;aIPAddress, PvUInt16 aLocalPort=0, PvUInt16 aChannelID=0, const PvString &amp;aLocalIpAddress=PvString(), PvUInt32 aBuffersCapacity=64)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamBase::Open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pv_string.html">PvString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aIPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt16&nbsp;</td>
          <td class="paramname"> <em>aLocalPort</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt16&nbsp;</td>
          <td class="paramname"> <em>aChannelID</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_pv_string.html">PvString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aLocalIPAddress</em> = <code><a class="el" href="class_pv_string.html">PvString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aBuffersCapacity</em> = <code>64</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begin receiving blocks (images or raw data) <b>unicasted</b> from a GigE Vision transmitter. </p>
<p>Note that this overload of Open is for receiving blocks that are unicasted from a GigE Vision transmitter to an interface on the same subnet. To receive multicasted data, refer to the other overload of the Open method (PvStreamBase::Open(const PvString &amp; aIpAddress,const PvString &amp;,PvUInt16,PvUInt16,const PvString &amp;))</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aIPAddress</em>&nbsp;</td><td>The GigE Vision transmitter's IP address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aLocalPort</em>&nbsp;</td><td>The local port upon which to begin receiving incoming data. A value of 0 (default) indicates that the local port will be assigned automatically. Call <a class="el" href="class_pv_stream_base.html#a7bfe1b9a25c3d893a8df7ef422d1d46e" title="Get the stream&#39;s DataPort property.">GetLocalPort</a> afterwards to obtain the port number that was assigned by the system. Set the streaming channel destination address (SCDA) on your GigE Vision transmitter accordingly by calling <a class="el" href="class_pv_device.html#ae8a7d5bbd04c8c73b639117768e37061" title="Set the UDP/IP destination to which the GigE Vision device transmits data.">PvDevice::SetStreamDestination</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aChannelID</em>&nbsp;</td><td>The GigE Vision transmitter's streaming channel (default 0). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aLocalIPAddress</em>&nbsp;</td><td>The local IP address upon which to begin receiving incoming data. An empty string (default) indicates that the local IP address will be assigned automatically. Call <a class="el" href="class_pv_stream_base.html#a159d2d68dcc8970c11fdb6ebada7ba2f" title="Get the stream&#39;s LocalIPAddress property.">GetLocalIPAddress</a> afterwards to obtain the local IP address that was assigned by the system. Set the streaming channel port number (SCP) on your GigE Vision transmitter accordingly by calling <a class="el" href="class_pv_device.html#ae8a7d5bbd04c8c73b639117768e37061" title="Set the UDP/IP destination to which the GigE Vision device transmits data.">PvDevice::SetStreamDestination</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aBuffersCapacity</em>&nbsp;</td><td>The maximum number of buffers that can be stored simultaneously in the data receiver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#ac9f683e6f2d696181b220cfd893e0482" title="The object (PvDevice or PvStream object) isn&#39;t connected.">PvResult::Code::NOT_CONNECTED</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a09821ccee069f171e970e1904b5ebdf8" title="An undefined error occurred.">PvResult::Code::GENERIC_ERROR</a></li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_pv_stream_base.html#a6566ab11aae4d630ea0888e7909c7b31" title="Begin receiving blocks (images or raw data) unicasted from a GigE Vision transmitter...">Open</a> </dd>
<dd>
<a class="el" href="class_pv_stream_base.html#a2742f5a2aab2f97c49fbfbe43ba4a248" title="Close the stream channel receiver.">Close</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adc26906a207c0ff5a44fa2ae0876ff1f"></a><!-- doxytag: member="PvStreamBase::QueueBuffer" ref="adc26906a207c0ff5a44fa2ae0876ff1f" args="(PvBuffer *aBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamBase::QueueBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>aBuffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queue a buffer to receive a block. </p>
<p>The <a class="el" href="class_pv_stream_base.html#adc26906a207c0ff5a44fa2ae0876ff1f" title="Queue a buffer to receive a block.">QueueBuffer</a> method queues in a buffer (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> object) to a stream (<a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision transmitter (data receiver properties dynamically...">PvStream</a> object) so it can be filled by the data receiver.</p>
<p>For each buffer you remove (using <a class="el" href="class_pv_stream_base.html#a3f53879cb4411d122757c99c73e67e3d" title="Attempt to retrieve a queued buffer.">RetrieveBuffer</a>), you should queue another (using <a class="el" href="class_pv_stream_base.html#adc26906a207c0ff5a44fa2ae0876ff1f" title="Queue a buffer to receive a block.">QueueBuffer</a>). <b>The maximum number of buffers that can be queued at a given time can be obtained by calling <a class="el" href="class_pv_stream_base.html#a0997241d2e81ffd0c2799ebf8b4034cc" title="Get the maximum number of buffers (PvBuffer objects) that can be queued at a time...">GetQueuedBufferMaximum</a>.</b> To reduce the risk of missing incoming data, it is recommended that several blocks remain queued and ready to go at any given time. Generally it is recommended that a larger number of buffers remain queued for higher frame rates. Larger block sizes with blocks being streamed at a lower frame rate can afford to allocate fewer buffers to optimize memory usage and reduce potential latency.</p>
<p>Once the stream fills the buffer with a block, retrieve the buffer by calling <a class="el" href="class_pv_stream_base.html#a3f53879cb4411d122757c99c73e67e3d" title="Attempt to retrieve a queued buffer.">RetrieveBuffer</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aBuffer</em>&nbsp;</td><td>A pointer to the buffer to be filled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#a5b1c14f61961fb914f4b1df6c2a8226a" title="Success! (Pending.).">PvResult::Code::PENDING</a> if the buffer has been properly queued</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a09821ccee069f171e970e1904b5ebdf8" title="An undefined error occurred.">PvResult::Code::GENERIC_ERROR</a> if the buffer could not be queued. See <a class="el" href="class_pv_result.html#aa6453a3e5111bc6c2b86fa3649216f85" title="Get the result description.">PvResult::GetDescription</a> for more information </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a17488b8b84e1522730452628a968e38e"></a><!-- doxytag: member="PvStreamBase::RegisterEventSink" ref="a17488b8b84e1522730452628a968e38e" args="(PvStreamBaseEventSink *aEventSink)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamBase::RegisterEventSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_stream_base_event_sink.html">PvStreamBaseEventSink</a> *&nbsp;</td>
          <td class="paramname"> <em>aEventSink</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register an event sink used for callbacks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aEventSink</em>&nbsp;</td><td>A pointer to the event sink.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a1fc2ef16100f16a44da2df392d010871" title="A parameter passed to the method is invalid.">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a09821ccee069f171e970e1904b5ebdf8" title="An undefined error occurred.">PvResult::Code::GENERIC_ERROR</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3f53879cb4411d122757c99c73e67e3d"></a><!-- doxytag: member="PvStreamBase::RetrieveBuffer" ref="a3f53879cb4411d122757c99c73e67e3d" args="(PvBuffer **aBuffer, PvResult *aOperationResult, PvUInt32 aTimeout=0xFFFFFFFF)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamBase::RetrieveBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> **&nbsp;</td>
          <td class="paramname"> <em>aBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pv_result.html">PvResult</a> *&nbsp;</td>
          <td class="paramname"> <em>aOperationResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aTimeout</em> = <code>0xFFFFFFFF</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to retrieve a queued buffer. </p>
<p>To use this method, see also <a class="el" href="class_pv_stream_base.html#adc26906a207c0ff5a44fa2ae0876ff1f" title="Queue a buffer to receive a block.">QueueBuffer</a>.</p>
<p>The <a class="el" href="class_pv_stream_base.html#a3f53879cb4411d122757c99c73e67e3d" title="Attempt to retrieve a queued buffer.">RetrieveBuffer</a> method blocks until one of the following occurs:</p>
<ul>
<li>The buffer is filled with a block (image or raw data).</li>
<li>The retrieve buffer operation times out: it exceeds <em>aTimeout</em>.</li>
<li>The acquisition fails (by being aborted, data receiver timeout as defined by ImageTimeout property, etc.)</li>
</ul>
<p>Once the method returns, you can determine the ultimate success of the image acquisition by testing the <em>aOperationResult</em> parameter. For example, <a class="el" href="class_pv_stream_base.html#a3f53879cb4411d122757c99c73e67e3d" title="Attempt to retrieve a queued buffer.">RetrieveBuffer</a> may return <a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a>, even if the operation was aborted (by a call to <a class="el" href="class_pv_stream_base.html#a40e2bd6c9a7e954abdb3baff26db62c1" title="Abort all pending block requests.">AbortQueuedBuffers</a> or <a class="el" href="class_pv_stream_base.html#a2742f5a2aab2f97c49fbfbe43ba4a248" title="Close the stream channel receiver.">Close</a>). In this case, <em>aOperationResult</em> would be <a class="el" href="struct_pv_result_1_1_code.html#aebff7679ec951c719bbf778fdaa8946e" title="The operation was aborted.">PvResult::Code::ABORTED</a>.</p>
<p>The return value contains the RetrieveBuffer operation results and <em>aOperationResult</em> contains the actual result (or failure) of the data receiver on this buffer. This method can succeed in providing you the oldest buffer but the result of the operation may still be a failure - if acquisition was aborted, incomplete, etc.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>aBuffer</em>&nbsp;</td><td>The buffer that holds the image. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>aOperationResult</em>&nbsp;</td><td>The ultimate result of the operation; a <a class="el" href="struct_pv_result_1_1_code.html" title="Error codes.">PvResult::Code</a>. Returns include:</p>
<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#a0a5e6e448df2b8396d06f5a29ad10786" title="An error code hasn&#39;t been set.">PvResult::Code::NOT_INITIALIZED</a> (only user-mode, eBUS Universal Pro)</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a4ae7dd2fea1befec898f58dbaa43e705" title="The operation timed out.">PvResult::Code::TIMEOUT</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#aebff7679ec951c719bbf778fdaa8946e" title="The operation was aborted.">PvResult::Code::ABORTED</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a684b0f34936b8fd7fe185c02edafd8f8" title="Some packets are missing in the buffer.">PvResult::Code::MISSING_PACKETS</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#aa5b0cd241d9a44e9ca7328b3bec5504c" title="The method is (probably) legal, but the system&#39;s current state doesn&#39;t allow...">PvResult::Code::STATE_ERROR</a> (only eBUS Optimal)</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#ae7f258f1acceecd4e1545af37e1b3b17" title="The buffer was not large enough to hold the payload of the block being received.">PvResult::Code::BUFFER_TOO_SMALL</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a99a2cfecf9ab3333cc0ae89c6e65ea96" title="Error with an image.">PvResult::Code::IMAGE_ERROR</a> for images with grabber issues like data overrun or missing lines (complete or partial)</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a1a7ae13f5cab3896697a450d746bd79f" title="Error receiving resend buffers - general failure.">PvResult::Code::RESENDS_FAILURE</a> (only user-mode, eBUS Universal Pro)</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#ac00902f025da63fab0bbd9a1d60cadd0" title="Error receiving resend buffers - too many were requested.">PvResult::Code::TOO_MANY_RESENDS</a> (only user-mode, eBUS Universal Pro)</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#ac790ee27ab88c28585c43ee46bd07f98" title="Buffer reception failed, consecutive missing buffers higher than allowed.">PvResult::Code::TOO_MANY_CONSECUTIVE_RESENDS</a> (only user-mode, eBUS Universal Pro)</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#ae92ad4087c47a9ab8c4c1dc801953771" title="The data format is not supported for the requested operation.">PvResult::Code::INVALID_DATA_FORMAT</a> (only user-mode, eBUS Universal Pro)</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#aaefea813923d39cbbe9eb42ac371de84" title="Buffer reception failed.">PvResult::Code::AUTO_ABORTED</a> (only user-mode, eBUS Universal Pro)</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#ac9f683e6f2d696181b220cfd893e0482" title="The object (PvDevice or PvStream object) isn&#39;t connected.">PvResult::Code::NOT_CONNECTED</a> -&gt; not connected</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a9d89cb550eb45951de1c200b92c1ba7b" title="No more of what was requested is currently available.">PvResult::Code::NO_MORE_ITEM</a> -&gt; no <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> queued </li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aTimeout</em>&nbsp;</td><td>The maximum time, in ms, to wait for a buffer to be returned by the data receiver. The default value (0xFFFFFFFF) uses the stream object's timeout (For <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision transmitter (data receiver properties dynamically...">PvStream</a>, the parameter is DefaultImageTimeout; for <a class="el" href="class_pv_stream_raw.html" title="Receive data from a GigE Vision transmitter (data receiver properties accessible...">PvStreamRaw</a>, use the value is set with <a class="el" href="class_pv_stream_raw.html#a1e25999cf712f57d08c2f49f963e16f1" title="Set the stream&#39;s DefaultBlockTimeout property.">PvStreamRaw::SetDefaultBlockTimeout</a>.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a4ae7dd2fea1befec898f58dbaa43e705" title="The operation timed out.">PvResult::Code::TIMEOUT</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae8d0a1ebcb370242ce2b5a99abc32fbc"></a><!-- doxytag: member="PvStreamBase::SetUserModeDataReceiverThreadPriority" ref="ae8d0a1ebcb370242ce2b5a99abc32fbc" args="(PvUInt32 aPriority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamBase::SetUserModeDataReceiverThreadPriority </td>
          <td>(</td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aPriority</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the priority of the thread used to run the data receiver user mode. </p>
<p>Only applicable if using a user-mode data receiver. The thread priority of a driver-based data receiver cannot be controlled. This thread receives and processes all packets received from the device.</p>
<p>If you change the thread priorities, it may alterate the stability of the system. For this reason, if you report a bug to Pleora, ensure to clearly mention that you change threads priorities.</p>
<p>See <a class="el" href="class_pv_stream_base.html#a43efae0ca2e8805e68d69e9390754b20" title="Get the priority of the thread used to run the data receiver user mode.">GetUserModeDataReceiverThreadPriority</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPriority</em>&nbsp;</td><td>See <a class="el" href="class_pv_pipeline.html#a74c783e57ea353cef63e110764c49584" title="Set the priority of the pipeline thread.">PvPipeline::SetBufferHandlingThreadPriority</a> for description of the supported values</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a1fc2ef16100f16a44da2df392d010871" title="A parameter passed to the method is invalid.">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#ae52ab12723d0e1686002b1924e51f358" title="An error occurred while attempting to perform an operation on a thread like starting...">PvResult::Code::THREAD_ERROR</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a05d76895d0f8ecf86500e30098297510"></a><!-- doxytag: member="PvStreamBase::UnregisterEventSink" ref="a05d76895d0f8ecf86500e30098297510" args="(PvStreamBaseEventSink *aEventSink)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamBase::UnregisterEventSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_stream_base_event_sink.html">PvStreamBaseEventSink</a> *&nbsp;</td>
          <td class="paramname"> <em>aEventSink</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregister an event sink. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aEventSink</em>&nbsp;</td><td>A pointer to the event sink.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a1fc2ef16100f16a44da2df392d010871" title="A parameter passed to the method is invalid.">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a73fb1b2f0a5004a6c8878ea9624b68eb" title="The expected item wasn&#39;t found.">PvResult::Code::NOT_FOUND</a></li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_pv_stream_base.html#a17488b8b84e1522730452628a968e38e" title="Register an event sink used for callbacks.">RegisterEventSink</a> </dd></dl>

</div>
</div>
</div>
<hr size="1">
<P><B>Copyright (c) 2002-2012 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>

