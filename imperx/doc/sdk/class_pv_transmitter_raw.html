<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>eBUS SDK C++ API: PvTransmitterRaw Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>

	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v3.0.4.2568 C++ API</h2>
		</div>
	</div>
		
		<br>
		<br>

	</body>
	
</html>


<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>PvTransmitterRaw Class Reference</h1><!-- doxytag: class="PvTransmitterRaw" -->
<p>Class for transmitting blocks using the GigE Vision streaming protocol.  
<a href="#_details">More...</a></p>

<p><a href="class_pv_transmitter_raw-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a221727dac1cae3ba7f58a272e9cc39b7">AbortQueuedBuffers</a> (PvUInt32 aTimeout=0xFFFFFFFF, bool *aPartialTransmission=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees all pending transmission requests.  <a href="#a221727dac1cae3ba7f58a272e9cc39b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a544877d11e8499a35995cad8f4ec47e2">Close</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop sending data and close the socket.  <a href="#a544877d11e8499a35995cad8f4ec47e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a91607fb084e67f55045de9ebe26dd548">GetAveragePayloadThroughput</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the average payload throughput (in bps).  <a href="#a91607fb084e67f55045de9ebe26dd548"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#af46895e6f12385f9f2f88a258b07c940">GetAverageTransmissionRate</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the average transmission rate (in blocks/second).  <a href="#af46895e6f12385f9f2f88a258b07c940"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#afdf67a444e3a6945b4968d15d9a6b231">GetBlocksTransmitted</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of blocks transmitted.  <a href="#afdf67a444e3a6945b4968d15d9a6b231"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a113176ff179643da4b54a36a59e8a2c6">GetBufferPoolThreadPriority</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the priority of the thread used to manage the buffer of the buffer pool.  <a href="#a113176ff179643da4b54a36a59e8a2c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_string.html">PvString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#af70bb2604de6c05e9d74b58cf0779bbd">GetDestinationIPAddress</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the IP address to which blocks are transmitted.  <a href="#af70bb2604de6c05e9d74b58cf0779bbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a4a5a62fb98e9a4217c5752668288fb96">GetDestinationPort</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the port to which blocks are transmitted.  <a href="#a4a5a62fb98e9a4217c5752668288fb96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#ac650040db8d9d79b4b96c8633c132bbf">GetInstantaneousPayloadThroughput</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an instantaneous calculation of the payload throughput (in bps).  <a href="#ac650040db8d9d79b4b96c8633c132bbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#af968135f2d8ee67a66eb0ac4e8fb13b0">GetInstantaneousTransmissionRate</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the instantaneous transmission rate (in blocks/second).  <a href="#af968135f2d8ee67a66eb0ac4e8fb13b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a5430114bdece3cb4d7048de1cc54b6b1">GetMaxPayloadThroughput</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum effective throughput in bps.  <a href="#a5430114bdece3cb4d7048de1cc54b6b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a508cca5f345448749b555e2083d9156a">GetPacketSize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum packet size of GVSP payload packets.  <a href="#a508cca5f345448749b555e2083d9156a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a0a2aed61af7eb80369f0cae637519b8b">GetPayloadBytesTransmitted</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of payload bytes transmitted.  <a href="#a0a2aed61af7eb80369f0cae637519b8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#acd6080fce676c5f35b3a5e38dd081602">GetQueuedBufferCount</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of buffers queued for transmission including the ones that are currently being sent.  <a href="#acd6080fce676c5f35b3a5e38dd081602"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a7d612a20ecb04047423c3ceff75ddaa3">GetSamplingTime</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the time since last reset.  <a href="#a7d612a20ecb04047423c3ceff75ddaa3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_string.html">PvString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a94c81a68f5428c9ef600a948a9244e85">GetSourceIPAddress</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the IP address from which blocks are transmitted.  <a href="#a94c81a68f5428c9ef600a948a9244e85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#ae3200eaaed764139a7429b841ad13191">GetSourcePort</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the port from which blocks are transmitted.  <a href="#ae3200eaaed764139a7429b841ad13191"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a3d4fdaf361ae21dbdda233c938a9506c">GetUserModeTransmitterThreadPriority</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the priority of the thread in charge of sending the packets on the network.  <a href="#a3d4fdaf361ae21dbdda233c938a9506c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a888606603bb502b9eabdd3e2843ca380">IsOpen</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a connection is available to begin transmitting blocks.  <a href="#a888606603bb502b9eabdd3e2843ca380"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a3b26d0ddb85384b419be5adbe18c63ac">LoadBufferPool</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> **aBuffers, PvUInt32 aBufferCount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a set of free buffers into the pool.  <a href="#a3b26d0ddb85384b419be5adbe18c63ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#abd14a57d5220bc0f679fc140c53a8806">Open</a> (<a class="el" href="class_pv_string.html">PvString</a> aDestinationIPAddress, PvUInt16 aDestinationPort, <a class="el" href="class_pv_string.html">PvString</a> aSourceIPAddress=&quot;&quot;, PvUInt16 aSourcePort=0, bool aDontFrag=true, bool aExtendedID=false, PvUInt32 aBuffersCapacity=64)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a socket to begin transmitting data.  <a href="#abd14a57d5220bc0f679fc140c53a8806"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#abb010fd9763909b21144b0d43769e64a">PvTransmitterRaw</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#abb010fd9763909b21144b0d43769e64a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#ac4db5831ee7f86ed83ce54c903e7dd32">QueueBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> *aBuffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue one buffer in to be transmitted when a connection is available.  <a href="#ac4db5831ee7f86ed83ce54c903e7dd32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a27b1d8a4987e1b92e2762e2f4621fead">ResetStats</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Zero all running counters.  <a href="#a27b1d8a4987e1b92e2762e2f4621fead"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a2f8a4fb72df44dcdb33c501abc75310b">RetrieveFreeBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> **aBuffer, PvUInt32 aTimeout=0xFFFFFFFF)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a free buffer from the list of available buffers.  <a href="#a2f8a4fb72df44dcdb33c501abc75310b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a79ad4a040f37fe96f4806b0d61d04691">SetBufferPoolThreadPriority</a> (PvUInt32 aPriority)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the priority of the thread used to manage the buffer of the buffer pool.  <a href="#a79ad4a040f37fe96f4806b0d61d04691"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a4d59ab09cdf41d1d07130db72641fc96">SetMaxPayloadThroughput</a> (float aMaxPayloadThroughput)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the desired effective throughput in bps.  <a href="#a4d59ab09cdf41d1d07130db72641fc96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#ac1e62eafd47ce796a7acf3e1cf384121">SetPacketSize</a> (PvUInt32 aPacketSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the maximum packet size of GVSP payload packets.  <a href="#ac1e62eafd47ce796a7acf3e1cf384121"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a3fe6c9bc87ccc01a9064262d7c1b9881">SetUserModeTransmitterThreadPriority</a> (PvUInt32 aPriority)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the priority of the thread in charge of sending the packets on the network.  <a href="#a3fe6c9bc87ccc01a9064262d7c1b9881"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_raw.html#a5fdf844e36f0505a0becb70689f65b99">~PvTransmitterRaw</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a5fdf844e36f0505a0becb70689f65b99"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class for transmitting blocks using the GigE Vision streaming protocol. </p>
<p><b>Procedure for transmitting blocks (images or raw data) with the eBUS SDK:</b></p>
<ul>
<li>Ensure that the transmitter knows where to send blocks by calling <a class="el" href="class_pv_transmitter_raw.html#abd14a57d5220bc0f679fc140c53a8806" title="Initialize a socket to begin transmitting data.">Open</a>.</li>
<li>Initialize the transmitter with a set of free buffers (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> objects) by calling <a class="el" href="class_pv_transmitter_raw.html#a3b26d0ddb85384b419be5adbe18c63ac" title="Load a set of free buffers into the pool.">LoadBufferPool</a>.</li>
<li>Retrieve a free buffer to populate by calling <a class="el" href="class_pv_transmitter_raw.html#a2f8a4fb72df44dcdb33c501abc75310b" title="Retrieve a free buffer from the list of available buffers.">RetrieveFreeBuffer</a>.</li>
<li>Queue a buffer for transmission by calling <a class="el" href="class_pv_transmitter_raw.html#ac4db5831ee7f86ed83ce54c903e7dd32" title="Queue one buffer in to be transmitted when a connection is available.">QueueBuffer</a>.</li>
<li>Once a buffer has been transmitted, it can be retrieved again by calling <a class="el" href="class_pv_transmitter_raw.html#a2f8a4fb72df44dcdb33c501abc75310b" title="Retrieve a free buffer from the list of available buffers.">RetrieveFreeBuffer</a>.</li>
</ul>
<p>The status of a given <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> object can be retrieved by calling <a class="el" href="class_pv_buffer.html#ab6089cf8573309e856216d0700beecca" title="Returns the value of aOperationResult when this buffer was last received through...">PvBuffer::GetOperationResult</a>.</p>
<ul>
<li>An operation result of <a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a> indicates that the buffer was transmitted successfully.</li>
<li>An operation result of <a class="el" href="struct_pv_result_1_1_code.html#a3667fb61710906064ba5cf5d72e07f9f" title="A network error occurred while performing the requested operation.">PvResult::Code::NETWORK_ERROR</a> indicates that there was a problem transmitting the buffer (likely due to a lack of connectivity).</li>
<li>An operation result of <a class="el" href="struct_pv_result_1_1_code.html#aebff7679ec951c719bbf778fdaa8946e" title="The operation was aborted.">PvResult::Code::ABORTED</a> indicates that the transmission of that buffer was aborted (typically by calling <a class="el" href="class_pv_transmitter_raw.html#a221727dac1cae3ba7f58a272e9cc39b7" title="Frees all pending transmission requests.">AbortQueuedBuffers</a>).</li>
<li>An operation result of <a class="el" href="struct_pv_result_1_1_code.html#a5b1c14f61961fb914f4b1df6c2a8226a" title="Success! (Pending.).">PvResult::Code::PENDING</a> indicates that the buffer has not yet been fully transmitted.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="class_pv_transmitter_raw.html" title="Class for transmitting blocks using the GigE Vision streaming protocol.">PvTransmitterRaw</a> is only responsible for transmitting blocks. It does not implement a control channel like a complete GigE Vision device. To receive transmitted blocks with a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision transmitter (data receiver properties dynamically...">PvStream</a> application (such as GEVPlayer), the transmitting application must be set up to respond to device discovery requests. Use <a class="el" href="class_pv_virtual_device.html" title="Virtual GigE Vision device.">PvVirtualDevice</a> to respond to device discovery requests. If using GEVPlayer or NetCommand to receive data being transmitted with this class, ensure that the application is set up as <b>Data Receiver Only</b>.</dd></dl>
<p>For an illustration of how this API is used in practice, refer to the following source code samples in the samples directory where the eBUS SDK resides.</p>
<ul>
<li>PvTransmitTestPatternSample - Transmits a test pattern to a given destination. Easiest starting point for learning to use <a class="el" href="class_pv_transmitter_raw.html" title="Class for transmitting blocks using the GigE Vision streaming protocol.">PvTransmitterRaw</a>.</li>
<li>PvTransmitRawSample - Transmits raw data to a given destination. To be used in conjunction with PvReceiveRawSample.</li>
<li>PvReceiveRawSample - Receives raw data from a given source.</li>
<li>PvTransmitVideoSample - Captures from either a video file or an installed capture device (such as a webcam) using OpenCV and transmits it to a given destination.</li>
<li>PvTransformAndTransmitSample - Receives video from a GigE Vision device using <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision transmitter (data receiver properties dynamically...">PvStream</a> and <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision transmitter.">PvPipeline</a>, resamples it and print text on it using OpenCV and finally transmits it using <a class="el" href="class_pv_transmitter_raw.html" title="Class for transmitting blocks using the GigE Vision streaming protocol.">PvTransmitterRaw</a>.</li>
<li>PvTransmitScreenSample - Captures the contents of the screen and transmits it to a given destination.</li>
<li>PvTransmitTiledImageSample - An MFC GUI application that receives video from multiple GEV transmitters, tiles into one video feed and transmits to a given destination. </li>
</ul>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abb010fd9763909b21144b0d43769e64a"></a><!-- doxytag: member="PvTransmitterRaw::PvTransmitterRaw" ref="abb010fd9763909b21144b0d43769e64a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvTransmitterRaw::PvTransmitterRaw </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="a5fdf844e36f0505a0becb70689f65b99"></a><!-- doxytag: member="PvTransmitterRaw::~PvTransmitterRaw" ref="a5fdf844e36f0505a0becb70689f65b99" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvTransmitterRaw::~PvTransmitterRaw </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a221727dac1cae3ba7f58a272e9cc39b7"></a><!-- doxytag: member="PvTransmitterRaw::AbortQueuedBuffers" ref="a221727dac1cae3ba7f58a272e9cc39b7" args="(PvUInt32 aTimeout=0xFFFFFFFF, bool *aPartialTransmission=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterRaw::AbortQueuedBuffers </td>
          <td>(</td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aTimeout</em> = <code>0xFFFFFFFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>aPartialTransmission</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees all pending transmission requests. </p>
<p>Buffers that were aborted will have an operation result set at <a class="el" href="struct_pv_result_1_1_code.html#aebff7679ec951c719bbf778fdaa8946e" title="The operation was aborted.">PvResult::Code::ABORTED</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aTimeout</em>&nbsp;</td><td>Represents the maximum number of milliseconds to wait for the current transmit operation before returning <a class="el" href="struct_pv_result_1_1_code.html#a4ae7dd2fea1befec898f58dbaa43e705" title="The operation timed out.">PvResult::Code::TIMEOUT</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPartialTransmission</em>&nbsp;</td><td>Output, set to true if transmission was stopped in the middle of a block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a> if successful </dd></dl>

</div>
</div>
<a class="anchor" id="a544877d11e8499a35995cad8f4ec47e2"></a><!-- doxytag: member="PvTransmitterRaw::Close" ref="a544877d11e8499a35995cad8f4ec47e2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterRaw::Close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stop sending data and close the socket. </p>
<p>Any buffers that are in the middle of being transmitted are aborted.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a> if successful </dd></dl>

</div>
</div>
<a class="anchor" id="a91607fb084e67f55045de9ebe26dd548"></a><!-- doxytag: member="PvTransmitterRaw::GetAveragePayloadThroughput" ref="a91607fb084e67f55045de9ebe26dd548" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float PvTransmitterRaw::GetAveragePayloadThroughput </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the average payload throughput (in bps). </p>
<p>Average payload transmission rate is equivalent to <a class="el" href="class_pv_transmitter_raw.html#a0a2aed61af7eb80369f0cae637519b8b" title="Get the number of payload bytes transmitted.">GetPayloadBytesTransmitted()</a> * 8 / <a class="el" href="class_pv_transmitter_raw.html#a7d612a20ecb04047423c3ceff75ddaa3" title="Get the time since last reset.">GetSamplingTime()</a>. Note that this calculation only includes the number of useful data bytes and does not include GVSP, IP and UDP header overhead. This function is the transmitter counterpart to <a class="el" href="class_pv_statistics.html#a4099f1b9dc0fd40cfca18941057d4787" title="Get the stream&#39;s BandwidthAverage property.">PvStatistics::GetBandwidthAverage()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The average network throughput (in bps) </dd></dl>

</div>
</div>
<a class="anchor" id="af46895e6f12385f9f2f88a258b07c940"></a><!-- doxytag: member="PvTransmitterRaw::GetAverageTransmissionRate" ref="af46895e6f12385f9f2f88a258b07c940" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float PvTransmitterRaw::GetAverageTransmissionRate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the average transmission rate (in blocks/second). </p>
<p>Average transmission rate is equivalent to <a class="el" href="class_pv_transmitter_raw.html#afdf67a444e3a6945b4968d15d9a6b231" title="Get the number of blocks transmitted.">GetBlocksTransmitted()</a> / <a class="el" href="class_pv_transmitter_raw.html#a7d612a20ecb04047423c3ceff75ddaa3" title="Get the time since last reset.">GetSamplingTime()</a>. This function is the transmitter counterpart to <a class="el" href="class_pv_statistics.html#a5d543e7fcd2da31b36f3d1d2d6e423c6" title="Get the stream&#39;s AcquisitionRateAverage property.">PvStatistics::GetAcquisitionRateAverage()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The average transmission rate (in blocks/second) </dd></dl>

</div>
</div>
<a class="anchor" id="afdf67a444e3a6945b4968d15d9a6b231"></a><!-- doxytag: member="PvTransmitterRaw::GetBlocksTransmitted" ref="afdf67a444e3a6945b4968d15d9a6b231" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt64 PvTransmitterRaw::GetBlocksTransmitted </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of blocks transmitted. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of blocks this object has transmitted. </dd></dl>

</div>
</div>
<a class="anchor" id="a113176ff179643da4b54a36a59e8a2c6"></a><!-- doxytag: member="PvTransmitterRaw::GetBufferPoolThreadPriority" ref="a113176ff179643da4b54a36a59e8a2c6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvTransmitterRaw::GetBufferPoolThreadPriority </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the priority of the thread used to manage the buffer of the buffer pool. </p>
<p>See <a class="el" href="class_pv_transmitter_raw.html#a79ad4a040f37fe96f4806b0d61d04691" title="Set the priority of the thread used to manage the buffer of the buffer pool.">SetBufferPoolThreadPriority</a> for details about the meaning of the values returned</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The priority of the thread </dd></dl>

</div>
</div>
<a class="anchor" id="af70bb2604de6c05e9d74b58cf0779bbd"></a><!-- doxytag: member="PvTransmitterRaw::GetDestinationIPAddress" ref="af70bb2604de6c05e9d74b58cf0779bbd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_string.html">PvString</a> PvTransmitterRaw::GetDestinationIPAddress </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the IP address to which blocks are transmitted. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The ip address to which blocks are transmitted. Returns an empty string when a connection has not yet been opened. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a5a62fb98e9a4217c5752668288fb96"></a><!-- doxytag: member="PvTransmitterRaw::GetDestinationPort" ref="a4a5a62fb98e9a4217c5752668288fb96" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt16 PvTransmitterRaw::GetDestinationPort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the port to which blocks are transmitted. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The port number to which blocks are transmitted. Returns 0 when a connection has not yet been opened. </dd></dl>

</div>
</div>
<a class="anchor" id="ac650040db8d9d79b4b96c8633c132bbf"></a><!-- doxytag: member="PvTransmitterRaw::GetInstantaneousPayloadThroughput" ref="ac650040db8d9d79b4b96c8633c132bbf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float PvTransmitterRaw::GetInstantaneousPayloadThroughput </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an instantaneous calculation of the payload throughput (in bps). </p>
<p>Instantaneous payload transmission rate is measured using a short time frame. Note that this calculation only includes the number of useful data bytes and does not include GVSP, IP and UDP header overhead. This function is the transmitter counterpart to <a class="el" href="class_pv_statistics.html#a443ee7398960852decb834816f070ae0" title="Get the stream&#39;s Bandwidth property.">PvStatistics::GetBandwidth()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The payload transmission rate (in bps) </dd></dl>

</div>
</div>
<a class="anchor" id="af968135f2d8ee67a66eb0ac4e8fb13b0"></a><!-- doxytag: member="PvTransmitterRaw::GetInstantaneousTransmissionRate" ref="af968135f2d8ee67a66eb0ac4e8fb13b0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float PvTransmitterRaw::GetInstantaneousTransmissionRate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the instantaneous transmission rate (in blocks/second). </p>
<p>Instantaneous transmission rate is measured using a short time frame. This function is the transmitter counterpart to <a class="el" href="class_pv_statistics.html#a8640e1548dbb165165cd4b063729ce7a" title="Get the stream&#39;s AcquisitionRate property.">PvStatistics::GetAcquisitionRate()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The instantaneous transmission rate (in blocks/second) </dd></dl>

</div>
</div>
<a class="anchor" id="a5430114bdece3cb4d7048de1cc54b6b1"></a><!-- doxytag: member="PvTransmitterRaw::GetMaxPayloadThroughput" ref="a5430114bdece3cb4d7048de1cc54b6b1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float PvTransmitterRaw::GetMaxPayloadThroughput </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the maximum effective throughput in bps. </p>
<p>An occasional delay is placed between the packets being transmitted to attempt to throttle the effective throughput. This helps to spread out network traffic to optimize bandwidth availability for other applications. A value of 0 (default) indicates that there should be no throttling based on throughput.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the desired throughput in bps. </dd></dl>

</div>
</div>
<a class="anchor" id="a508cca5f345448749b555e2083d9156a"></a><!-- doxytag: member="PvTransmitterRaw::GetPacketSize" ref="a508cca5f345448749b555e2083d9156a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvTransmitterRaw::GetPacketSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the maximum packet size of GVSP payload packets. </p>
<p>When a block is packetized and transmitted, the payload is broken down into packets of a given size. The default value for the maximum packet size is 1440 because that is the size that should work in theory for all network adapters.</p>
<p>For best results, enable jumbo packets in your network adapter properties and increase the maximum packet size to match When sending very small blocks at high frame rates it may sometimes be desirable to set the maximum packet size to a lower number.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The maximum packet size (in bytes). </dd></dl>

</div>
</div>
<a class="anchor" id="a0a2aed61af7eb80369f0cae637519b8b"></a><!-- doxytag: member="PvTransmitterRaw::GetPayloadBytesTransmitted" ref="a0a2aed61af7eb80369f0cae637519b8b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt64 PvTransmitterRaw::GetPayloadBytesTransmitted </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of payload bytes transmitted. </p>
<p>Note that this value only includes the number of useful data bytes and does not include GVSP, IP and UDP header overhead.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of payload bytes transmitted. </dd></dl>

</div>
</div>
<a class="anchor" id="acd6080fce676c5f35b3a5e38dd081602"></a><!-- doxytag: member="PvTransmitterRaw::GetQueuedBufferCount" ref="acd6080fce676c5f35b3a5e38dd081602" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvTransmitterRaw::GetQueuedBufferCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of buffers queued for transmission including the ones that are currently being sent. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of buffers queued for transmission including the ones that are currently being sent. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d612a20ecb04047423c3ceff75ddaa3"></a><!-- doxytag: member="PvTransmitterRaw::GetSamplingTime" ref="a7d612a20ecb04047423c3ceff75ddaa3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt64 PvTransmitterRaw::GetSamplingTime </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the time since last reset. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The time, in ms, since the counters were zeroed; the time since the object was created, the transmitter was opened (using <a class="el" href="class_pv_transmitter_raw.html#abd14a57d5220bc0f679fc140c53a8806" title="Initialize a socket to begin transmitting data.">Open</a>), or <a class="el" href="class_pv_transmitter_raw.html#a27b1d8a4987e1b92e2762e2f4621fead" title="Zero all running counters.">ResetStats</a> was called. </dd></dl>

</div>
</div>
<a class="anchor" id="a94c81a68f5428c9ef600a948a9244e85"></a><!-- doxytag: member="PvTransmitterRaw::GetSourceIPAddress" ref="a94c81a68f5428c9ef600a948a9244e85" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_string.html">PvString</a> PvTransmitterRaw::GetSourceIPAddress </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the IP address from which blocks are transmitted. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The IP address from which blocks are transmitted. Returns an empty string when a connection has not yet been opened. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3200eaaed764139a7429b841ad13191"></a><!-- doxytag: member="PvTransmitterRaw::GetSourcePort" ref="ae3200eaaed764139a7429b841ad13191" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt16 PvTransmitterRaw::GetSourcePort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the port from which blocks are transmitted. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The port number from which blocks are transmitted. Returns 0 when a connection has not yet been opened. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d4fdaf361ae21dbdda233c938a9506c"></a><!-- doxytag: member="PvTransmitterRaw::GetUserModeTransmitterThreadPriority" ref="a3d4fdaf361ae21dbdda233c938a9506c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvTransmitterRaw::GetUserModeTransmitterThreadPriority </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the priority of the thread in charge of sending the packets on the network. </p>
<p>See <a class="el" href="class_pv_transmitter_raw.html#a3fe6c9bc87ccc01a9064262d7c1b9881" title="Set the priority of the thread in charge of sending the packets on the network.">SetUserModeTransmitterThreadPriority</a> for details about the meaning of the values returned</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The priority of the thread </dd></dl>

</div>
</div>
<a class="anchor" id="a888606603bb502b9eabdd3e2843ca380"></a><!-- doxytag: member="PvTransmitterRaw::IsOpen" ref="a888606603bb502b9eabdd3e2843ca380" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvTransmitterRaw::IsOpen </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether a connection is available to begin transmitting blocks. </p>
<p>Call <a class="el" href="class_pv_transmitter_raw.html#abd14a57d5220bc0f679fc140c53a8806" title="Initialize a socket to begin transmitting data.">Open</a> to ensure that the tranmitter knows where to begin transmitting blocks.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if a connection is available. False if no connection is available. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b26d0ddb85384b419be5adbe18c63ac"></a><!-- doxytag: member="PvTransmitterRaw::LoadBufferPool" ref="a3b26d0ddb85384b419be5adbe18c63ac" args="(PvBuffer **aBuffers, PvUInt32 aBufferCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterRaw::LoadBufferPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> **&nbsp;</td>
          <td class="paramname"> <em>aBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aBufferCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a set of free buffers into the pool. </p>
<p>This method provides the transmitter with a set of free buffers that can be retrieved immediately by calling <a class="el" href="class_pv_transmitter_raw.html#a2f8a4fb72df44dcdb33c501abc75310b" title="Retrieve a free buffer from the list of available buffers.">RetrieveFreeBuffer</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aBuffers</em>&nbsp;</td><td>An array of pointers to <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> objects. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aBufferCount</em>&nbsp;</td><td>The number of buffer pointers provided.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a> if successful </dd></dl>

</div>
</div>
<a class="anchor" id="abd14a57d5220bc0f679fc140c53a8806"></a><!-- doxytag: member="PvTransmitterRaw::Open" ref="abd14a57d5220bc0f679fc140c53a8806" args="(PvString aDestinationIPAddress, PvUInt16 aDestinationPort, PvString aSourceIPAddress=&quot;&quot;, PvUInt16 aSourcePort=0, bool aDontFrag=true, bool aExtendedID=false, PvUInt32 aBuffersCapacity=64)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterRaw::Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_string.html">PvString</a>&nbsp;</td>
          <td class="paramname"> <em>aDestinationIp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt16&nbsp;</td>
          <td class="paramname"> <em>aDestinationPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pv_string.html">PvString</a>&nbsp;</td>
          <td class="paramname"> <em>aSourceIp</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt16&nbsp;</td>
          <td class="paramname"> <em>aSourcePort</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aDontFrag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aExtendedID</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aBuffersCapacity</em> = <code>64</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a socket to begin transmitting data. </p>
<p>Once this call is completed successfully, the transmitter will begin sending blocks as soon as the first buffer is queued in by calling <a class="el" href="class_pv_transmitter_raw.html#ac4db5831ee7f86ed83ce54c903e7dd32" title="Queue one buffer in to be transmitted when a connection is available.">QueueBuffer</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aDestinationIp</em>&nbsp;</td><td>The address to which the transmitter will send. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aDestinationPort</em>&nbsp;</td><td>The port to which the transmitter will send. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aSourceIp</em>&nbsp;</td><td>The address from which the transmitter will send. If the parameter is an empty string (default), the socket will not be bound to a particular local IP address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aSourcePort</em>&nbsp;</td><td>The port from which the transmitter will send. If the parameter is 0 (default), the source port will be dynamically assigned by the operating system. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aDontFrag</em>&nbsp;</td><td>The value of the Don't Fragment flag in the IP header. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aExtendedID</em>&nbsp;</td><td>Use the extended id for the blocks and the packets when set to true. [ This parameter is not supported in the current version of the SDK ] </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aBuffersCapacity</em>&nbsp;</td><td>Maximum number of buffer that can be stored simultaneously in the lower layer of the transmitter. This should only be enabled when the receiver is GEV 2.0 compliant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a> if successful <a class="el" href="struct_pv_result_1_1_code.html#a3667fb61710906064ba5cf5d72e07f9f" title="A network error occurred while performing the requested operation.">PvResult::Code::NETWORK_ERROR</a> if the socket could not be created </dd></dl>

</div>
</div>
<a class="anchor" id="ac4db5831ee7f86ed83ce54c903e7dd32"></a><!-- doxytag: member="PvTransmitterRaw::QueueBuffer" ref="ac4db5831ee7f86ed83ce54c903e7dd32" args="(PvBuffer *aBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterRaw::QueueBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>aBuffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queue one buffer in to be transmitted when a connection is available. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aBuffer</em>&nbsp;</td><td>The buffer to transmit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a> if successful. <a class="el" href="struct_pv_result_1_1_code.html#ae7f258f1acceecd4e1545af37e1b3b17" title="The buffer was not large enough to hold the payload of the block being received.">PvResult::Code::BUFFER_TOO_SMALL</a> if the buffer is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a27b1d8a4987e1b92e2762e2f4621fead"></a><!-- doxytag: member="PvTransmitterRaw::ResetStats" ref="a27b1d8a4987e1b92e2762e2f4621fead" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PvTransmitterRaw::ResetStats </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Zero all running counters. </p>

</div>
</div>
<a class="anchor" id="a2f8a4fb72df44dcdb33c501abc75310b"></a><!-- doxytag: member="PvTransmitterRaw::RetrieveFreeBuffer" ref="a2f8a4fb72df44dcdb33c501abc75310b" args="(PvBuffer **aBuffer, PvUInt32 aTimeout=0xFFFFFFFF)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterRaw::RetrieveFreeBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> **&nbsp;</td>
          <td class="paramname"> <em>aBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aTimeout</em> = <code>0xFFFFFFFF</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a free buffer from the list of available buffers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>aBuffer</em>&nbsp;</td><td>The buffer that is available to populate and transmit. The pointer is set to NULL if no buffer is available. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aTimeout</em>&nbsp;</td><td>The maximum number of milliseconds to wait for a free buffer to become available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a> if successful.or <a class="el" href="struct_pv_result_1_1_code.html#a4ae7dd2fea1befec898f58dbaa43e705" title="The operation timed out.">PvResult::Code::TIMEOUT</a> if the aTimeout parameter was exceeded while waiting for a buffer to become available. </dd></dl>

</div>
</div>
<a class="anchor" id="a79ad4a040f37fe96f4806b0d61d04691"></a><!-- doxytag: member="PvTransmitterRaw::SetBufferPoolThreadPriority" ref="a79ad4a040f37fe96f4806b0d61d04691" args="(PvUInt32 aPriority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterRaw::SetBufferPoolThreadPriority </td>
          <td>(</td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aPriority</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the priority of the thread used to manage the buffer of the buffer pool. </p>
<p>Only applicable if using a buffer pool ( See <a class="el" href="class_pv_transmitter_raw.html#a3b26d0ddb85384b419be5adbe18c63ac" title="Load a set of free buffers into the pool.">LoadBufferPool</a> ). The thread will manage the buffer exchange with the transmitter.</p>
<p>If you change the thread priorities, it may alterate the stability of the system. For this reason, if you report a bug to Pleora, ensure to clearly mention that you change threads priorities.</p>
<p>See <a class="el" href="class_pv_transmitter_raw.html#a113176ff179643da4b54a36a59e8a2c6" title="Get the priority of the thread used to manage the buffer of the buffer pool.">GetBufferPoolThreadPriority</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPriority</em>&nbsp;</td><td>See <a class="el" href="class_pv_pipeline.html#a74c783e57ea353cef63e110764c49584" title="Set the priority of the pipeline thread.">PvPipeline::SetBufferHandlingThreadPriority</a> for description of the supported values</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a1fc2ef16100f16a44da2df392d010871" title="A parameter passed to the method is invalid.">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#ae52ab12723d0e1686002b1924e51f358" title="An error occurred while attempting to perform an operation on a thread like starting...">PvResult::Code::THREAD_ERROR</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4d59ab09cdf41d1d07130db72641fc96"></a><!-- doxytag: member="PvTransmitterRaw::SetMaxPayloadThroughput" ref="a4d59ab09cdf41d1d07130db72641fc96" args="(float aMaxPayloadThroughput)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterRaw::SetMaxPayloadThroughput </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>aMaxPayloadThroughput</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the desired effective throughput in bps. </p>
<p>An occasional delay is placed between the packets being transmitted to attempt to throttle the effective throughput. This helps to spread out network traffic to optimize bandwidth availability for other applications. A value of 0 (default) indicates that there should be no throttling based on throughput.</p>
<p>The throughput is measured in effective throughput on the content of the transmitted <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> objects. It does not take into account the GigE Vision, UDP, IP and Ethernet protocol overhead of the packetized data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aMaxPayloadThroughput</em>&nbsp;</td><td>The maximum throughput in bps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a> if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1e62eafd47ce796a7acf3e1cf384121"></a><!-- doxytag: member="PvTransmitterRaw::SetPacketSize" ref="ac1e62eafd47ce796a7acf3e1cf384121" args="(PvUInt32 aPacketSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterRaw::SetPacketSize </td>
          <td>(</td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aPacketSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the maximum packet size of GVSP payload packets. </p>
<p>When a block is packetized and transmitted, the payload is broken down into packets of a given size. The default value for the maximum packet size is 1440 because that is the size that should work in theory for all network adapters.</p>
<p>For best results, enable jumbo packets in your network adapter properties and increase the maximum packet size to match When sending very small blocks at high frame rates it may sometimes be desirable to set the maximum packet size to a lower number.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPacketSize</em>&nbsp;</td><td>The maximum packet size (in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a> if successful, <a class="el" href="struct_pv_result_1_1_code.html#a1fc2ef16100f16a44da2df392d010871" title="A parameter passed to the method is invalid.">PvResult::Code::INVALID_PARAMETER</a> if aPacketSize is less than or equal to 36 </dd></dl>

</div>
</div>
<a class="anchor" id="a3fe6c9bc87ccc01a9064262d7c1b9881"></a><!-- doxytag: member="PvTransmitterRaw::SetUserModeTransmitterThreadPriority" ref="a3fe6c9bc87ccc01a9064262d7c1b9881" args="(PvUInt32 aPriority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterRaw::SetUserModeTransmitterThreadPriority </td>
          <td>(</td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aPriority</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the priority of the thread in charge of sending the packets on the network. </p>
<p>Only applicable if using a user-mode transmitter. The thread priority of a driver-based transmitter cannot be controlled. Thread that is responsible for breaking buffers in packets and transmitting them.</p>
<p>If you change the thread priorities, it may alterate the stability of the system. For this reason, if you report a bug to Pleora, ensure to clearly mention that you change threads priorities.</p>
<p>See <a class="el" href="class_pv_transmitter_raw.html#a3d4fdaf361ae21dbdda233c938a9506c" title="Get the priority of the thread in charge of sending the packets on the network.">GetUserModeTransmitterThreadPriority</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPriority</em>&nbsp;</td><td>See <a class="el" href="class_pv_pipeline.html#a74c783e57ea353cef63e110764c49584" title="Set the priority of the pipeline thread.">PvPipeline::SetBufferHandlingThreadPriority</a> for description of the supported values</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a1fc2ef16100f16a44da2df392d010871" title="A parameter passed to the method is invalid.">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#ae52ab12723d0e1686002b1924e51f358" title="An error occurred while attempting to perform an operation on a thread like starting...">PvResult::Code::THREAD_ERROR</a> </li>
</ul>
</dd></dl>

</div>
</div>
</div>
<hr size="1">
<P><B>Copyright (c) 2002-2012 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>

