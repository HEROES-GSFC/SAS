<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>eBUS SDK C++ API: PvBuffer Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>

	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v3.0.4.2568 C++ API</h2>
		</div>
	</div>
		
		<br>
		<br>

	</body>
	
</html>


<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>PvBuffer Class Reference</h1><!-- doxytag: class="PvBuffer" -->
<p>Represents a block of GigE Vision data in memory.  
<a href="#_details">More...</a></p>

<p><a href="class_pv_buffer-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#adaaccc11c6cf44df0a6d6d5fb3e16810">Alloc</a> (PvUInt32 aSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates memory for this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a>.  <a href="#adaaccc11c6cf44df0a6d6d5fb3e16810"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a72ed401eab17a510c3e420432837e4b7">Attach</a> (void *aBuffer, PvUInt32 aSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> to an external memory buffer.  <a href="#a72ed401eab17a510c3e420432837e4b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt8 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a78b6a8db8a3210b8982ede1d98e4b243">Detach</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases an attached memory buffer.  <a href="#a78b6a8db8a3210b8982ede1d98e4b243"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a897632d211ffca6e730d13f58447d1d9">Free</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees (de-allocates) the buffer's internal memory.  <a href="#a897632d211ffca6e730d13f58447d1d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a4adc07be05c831b6a781bceefca920e6">GetAcquiredSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the size of the payload received by the data receiver.  <a href="#a4adc07be05c831b6a781bceefca920e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ab09f72645ff3b6b8ce3c1cbef9cc200b">GetBlockID</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the block ID.  <a href="#ab09f72645ff3b6b8ce3c1cbef9cc200b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt8 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a8664a7194c866cf60f1c1c00f921c811">GetDataPointer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the buffer's data pointer.  <a href="#a8664a7194c866cf60f1c1c00f921c811"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const PvUInt8 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a1a0646afa2bae0f259f57e3d32b6448f">GetDataPointer</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the buffer's data pointer.  <a href="#a1a0646afa2bae0f259f57e3d32b6448f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#acac1f8e6ba0cbd983576e19e970c466c">GetID</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the buffer's ID.  <a href="#acac1f8e6ba0cbd983576e19e970c466c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aa4a16619899488226618a5b75f432a45">GetIgnoredPacketCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packets received that were ignored when this buffer was filled by the data receiver.  <a href="#aa4a16619899488226618a5b75f432a45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_pv_image.html">PvImage</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ab6b18ddca1320afb60baceebcf0f395d">GetImage</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface to the buffer.  <a href="#ab6b18ddca1320afb60baceebcf0f395d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_image.html">PvImage</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aa0e84f98d2c01c33aa6d58343fc242fc">GetImage</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface to the buffer.  <a href="#aa0e84f98d2c01c33aa6d58343fc242fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a2a8d3debf9d5bc310701ce87edfff3d4">GetLostPacketCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packets that were not successfully delivered when this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> was filled by the data receiver.  <a href="#a2a8d3debf9d5bc310701ce87edfff3d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ae3a747cda9952163e0c43dc1d123145b">GetMissingPacketIds</a> (PvUInt32 aIndex, PvUInt32 &amp;aPacketIdLow, PvUInt32 &amp;aPacketIdHigh)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a missing packet group that represents an unpopulated area of memory in this buffer.  <a href="#ae3a747cda9952163e0c43dc1d123145b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a8867f63f913076be52ee0e5add2c9bb3">GetMissingPacketIdsCount</a> (PvUInt32 &amp;aCount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of missing packet groups that represent unpopulated areas of memory in this buffer.  <a href="#a8867f63f913076be52ee0e5add2c9bb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ab6089cf8573309e856216d0700beecca">GetOperationResult</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value of aOperationResult when this buffer was last received through a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision transmitter (data receiver properties dynamically...">PvStream</a>.  <a href="#ab6089cf8573309e856216d0700beecca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a03ff511a9e57369d5c4832bfcca0e2bc">GetPacketOutOfOrderCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of packets received out of order.  <a href="#a03ff511a9e57369d5c4832bfcca0e2bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#adbc6276c6cba843fe2dc994f7d6e1879">GetPacketsRecoveredCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of lost packets successfully recovered by packet resend requests. Duplicate received packets are not counted.  <a href="#adbc6276c6cba843fe2dc994f7d6e1879"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a6a9fe79913021bfce23d64df1d6b1ce7">GetPacketsRecoveredSingleResendCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of lost packets successfully recovered by packet resend requests without any resend request retries.  <a href="#a6a9fe79913021bfce23d64df1d6b1ce7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#af12443f42dd7cc60f6f158cc0b433122">GetPayloadType</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the payload type currently used by the buffer.  <a href="#af12443f42dd7cc60f6f158cc0b433122"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_pv_raw_data.html">PvRawData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a15b8859e0461528b5a8d3be72e722549">GetRawData</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer.">PvRawData</a> interface to the buffer.  <a href="#a15b8859e0461528b5a8d3be72e722549"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_raw_data.html">PvRawData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aeecd2a17dd53ef52ad1873bdb63df1b4">GetRawData</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer.">PvRawData</a> interface to the buffer.  <a href="#aeecd2a17dd53ef52ad1873bdb63df1b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a9afef8b69586f139a13f51591e3424ca">GetRedundantPacketCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of packets received more than once.  <a href="#a9afef8b69586f139a13f51591e3424ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a94ed8b64fbcdd832271eae0d338150e5">GetRequiredSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the size of buffer required to hold the acquired block.  <a href="#a94ed8b64fbcdd832271eae0d338150e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a2aab5ebb5e9c3c6b6062134973c4db4b">GetResendGroupRequestedCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of resend requests issued by the data receiver.  <a href="#a2aab5ebb5e9c3c6b6062134973c4db4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a521d00b4ae59ecfb38476f8aa24e9c65">GetResendPacketRequestedCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of packets the data receiver requests with ResendGroupRequested.  <a href="#a521d00b4ae59ecfb38476f8aa24e9c65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a73d5467e8e1e198a7268e432ab22bf16">GetSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the buffer's size (total capacity) in bytes.  <a href="#a73d5467e8e1e198a7268e432ab22bf16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PvUInt64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a7cf2ba1ca5d1978ea1098cf150dacd17">GetTimestamp</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the buffer's timestamp.  <a href="#a7cf2ba1ca5d1978ea1098cf150dacd17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#afb764127bb8864f866ef812cd2dc1e61">IsExtendedID</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the buffer is currently in extended ID mode.  <a href="#afb764127bb8864f866ef812cd2dc1e61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#afedeb78adc823aff996d5682f4fdeac0">IsHeaderValid</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether this buffer has valid header (GVSP) information.  <a href="#afedeb78adc823aff996d5682f4fdeac0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a3c7d71796bff6856871b1d6468a1f2df">IsTrailerValid</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether this buffer has valid trailer (GVSP) information.  <a href="#a3c7d71796bff6856871b1d6468a1f2df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aec685815f08f9a47e7f8df24f8d90547">PvBuffer</a> (<a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a> aPayloadType=PvPayloadTypeImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#aec685815f08f9a47e7f8df24f8d90547"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a1ec5abd18467aa4855a6ba46e22c6b02">Reset</a> (<a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a> aPayloadType=PvPayloadTypeImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reconstruct the object with a new payload type.  <a href="#a1ec5abd18467aa4855a6ba46e22c6b02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a49e4f9872d5d1270944c1b8f183b6bde">SetID</a> (PvUInt64 aValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the buffer's ID.  <a href="#a49e4f9872d5d1270944c1b8f183b6bde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#af6c2e9572443c6969f2b1e45ea30829f">SetTimestamp</a> (PvUInt64 aTimestamp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the timestamp to place in the block leader.  <a href="#af6c2e9572443c6969f2b1e45ea30829f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a035a8711b365606fd6ec2d9b609b6b37">~PvBuffer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a035a8711b365606fd6ec2d9b609b6b37"></a><br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd7bc3879443389244a8500bf7e99744"></a><!-- doxytag: member="PvBuffer::PvBufferConverter" ref="acd7bc3879443389244a8500bf7e99744" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#acd7bc3879443389244a8500bf7e99744">PvBufferConverter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63d407fd60aabb54ab3ffea9e15f87ba"></a><!-- doxytag: member="PvBuffer::PvFilterDeinterlace" ref="a63d407fd60aabb54ab3ffea9e15f87ba" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a63d407fd60aabb54ab3ffea9e15f87ba">PvFilterDeinterlace</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8add5c181c442ee89734d5d0f319b1c1"></a><!-- doxytag: member="PvBuffer::PvFilterRGB" ref="a8add5c181c442ee89734d5d0f319b1c1" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a8add5c181c442ee89734d5d0f319b1c1">PvFilterRGB</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbebe17463fe09a03e19c5ac67193db8"></a><!-- doxytag: member="PvBuffer::PvPipeline" ref="afbebe17463fe09a03e19c5ac67193db8" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#afbebe17463fe09a03e19c5ac67193db8">PvPipeline</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5293de3ca8ef70dc1b83f78c16b3b8ce"></a><!-- doxytag: member="PvBuffer::PvStreamBase" ref="a5293de3ca8ef70dc1b83f78c16b3b8ce" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a5293de3ca8ef70dc1b83f78c16b3b8ce">PvStreamBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4e8146f731086fb76242cf2a8d8d7e6"></a><!-- doxytag: member="PvBuffer::PvTransmitterRaw" ref="aa4e8146f731086fb76242cf2a8d8d7e6" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aa4e8146f731086fb76242cf2a8d8d7e6">PvTransmitterRaw</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Represents a block of GigE Vision data in memory. </p>
<p>A <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> object is typically used to receive data from a GigE Vision transmitter or to transmit data to a GigE Vision receiver. To learn about receiving data from a GigE Vision transmitter, see <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision transmitter (data receiver properties dynamically...">PvStream</a>. To learn about transmitting GigE Vision data to a GigE Vision receiver, see <a class="el" href="class_pv_transmitter_raw.html" title="Class for transmitting blocks using the GigE Vision streaming protocol.">PvTransmitterRaw</a>.</p>
<p>A block of GigE Vision data has an associated payload which can be an image, raw data, file, chunk data, extended chunk data or device specific.</p>
<p>In order to access the payload specific data, use methods like <a class="el" href="class_pv_buffer.html#aa0e84f98d2c01c33aa6d58343fc242fc" title="Returns the PvImage interface to the buffer.">PvBuffer::GetImage</a> in order to get a pointer to an interface giving you access to payload specific methods and properties.</p>
<p>The current payload type of a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> can be determined by using the <a class="el" href="class_pv_buffer.html#af12443f42dd7cc60f6f158cc0b433122" title="Returns the payload type currently used by the buffer.">PvBuffer::GetPayloadType</a> method.</p>
<p>In this section:</p>
<ul>
<li><a href="#configuring">Creating and configuring buffers</a></li>
<li><a href="#accessing">Accessing payload type specific data</a></li>
<li><a href="#processing">Processing images</a></li>
</ul>
<h2 id="configuring">Creating and configuring buffers</h2>
<p><b>To create and configure buffers:</b></p>
<ol type="1">
<li>Create several buffers using the default constructor.</li>
<li>Set the size of the buffer. The method you use depends on whether you want to use an internally or externally controlled block of memory:<ul>
<li>To use memory that the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> object allocates and owns, use <a class="el" href="class_pv_buffer.html#adaaccc11c6cf44df0a6d6d5fb3e16810" title="Allocates memory for this PvBuffer.">Alloc</a>.</li>
<li>To use memory that you control (external to the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> object), use <a class="el" href="class_pv_buffer.html#a72ed401eab17a510c3e420432837e4b7" title="Attach this PvBuffer to an external memory buffer.">Attach</a>.</li>
</ul>
</li>
</ol>
<h2 id="accessing">Accessing payload type specific data</h2>
<p><b>To determine the payload type and access payload type specific data:</b></p>
<ol type="1">
<li>Retrieve the <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f" title="GVSP payload type.">PvPayloadType</a> using <a class="el" href="class_pv_buffer.html#af12443f42dd7cc60f6f158cc0b433122" title="Returns the payload type currently used by the buffer.">PvBuffer::GetPayloadType</a></li>
<li>If <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f" title="GVSP payload type.">PvPayloadType</a> is <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30faeb97a52f2036290b6213951f7782c841">PvPayloadTypeImage</a>, retrieve <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> pointer from your <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a></li>
<li>Access image specific data through the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> pointer, like <a class="el" href="class_pv_image.html#a9f625bda4f8933b967619d1ff20d3d8f" title="Get the image&#39;s width.">PvImage::GetWidth</a>, <a class="el" href="class_pv_image.html#a6baa291e84982e5452c4b74234c1d10c" title="Get the image&#39;s height.">PvImage::GetHeight</a>, etc.</li>
<li>There is no need to release or delete the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> pointer. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> exists.</li>
</ol>
<h2 id="processing">Processing images</h2>
<p><b>To process an image:</b></p>
<ol type="1">
<li>Retrieve a <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface to the buffer use <a class="el" href="class_pv_buffer.html#aa0e84f98d2c01c33aa6d58343fc242fc" title="Returns the PvImage interface to the buffer.">GetImage</a></li>
<li>Test the success of the image acquisition. Use the <em>aOperationResult</em> parameter in <a class="el" href="class_pv_stream_base.html#a3f53879cb4411d122757c99c73e67e3d" title="Attempt to retrieve a queued buffer.">PvStream::RetrieveBuffer</a> or <a class="el" href="class_pv_buffer.html#ab6089cf8573309e856216d0700beecca" title="Returns the value of aOperationResult when this buffer was last received through...">PvBuffer::GetOperationResult</a></li>
<li>Process the image using your own code. You may process the image in place, if you wish. Use:<ul>
<li>PvImage::GetAcquiredSize</li>
<li><a class="el" href="class_pv_image.html#a6baa291e84982e5452c4b74234c1d10c" title="Get the image&#39;s height.">PvImage::GetHeight</a> and <a class="el" href="class_pv_image.html#a9f625bda4f8933b967619d1ff20d3d8f" title="Get the image&#39;s width.">PvImage::GetWidth</a></li>
<li><a class="el" href="class_pv_image.html#a0c11016f88340d0f5d88ab672b562db3" title="Get the image&#39;s horizontal offset.">PvImage::GetOffsetX</a> and <a class="el" href="class_pv_image.html#aff0bcc003aa400653ca6241f724582a9" title="Get the image&#39;s vertical offset.">PvImage::GetOffsetY</a> </li>
</ul>
</li>
</ol>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aec685815f08f9a47e7f8df24f8d90547"></a><!-- doxytag: member="PvBuffer::PvBuffer" ref="aec685815f08f9a47e7f8df24f8d90547" args="(PvPayloadType aPayloadType=PvPayloadTypeImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvBuffer::PvBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a>&nbsp;</td>
          <td class="paramname"> <em>aPayloadType</em> = <code>PvPayloadTypeImage</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPayloadType</em>&nbsp;</td><td>The block type (default PvPayloadTypeImage). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a035a8711b365606fd6ec2d9b609b6b37"></a><!-- doxytag: member="PvBuffer::~PvBuffer" ref="a035a8711b365606fd6ec2d9b609b6b37" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvBuffer::~PvBuffer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="adaaccc11c6cf44df0a6d6d5fb3e16810"></a><!-- doxytag: member="PvBuffer::Alloc" ref="adaaccc11c6cf44df0a6d6d5fb3e16810" args="(PvUInt32 aSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::Alloc </td>
          <td>(</td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates memory for this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aSize</em>&nbsp;</td><td>The size of the buffer, in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af3b30f8e00bd6032aa0006d5aff5f606" title="Not enough memory.">PvResult::Code::NOT_ENOUGH_MEMORY</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a72ed401eab17a510c3e420432837e4b7"></a><!-- doxytag: member="PvBuffer::Attach" ref="a72ed401eab17a510c3e420432837e4b7" args="(void *aBuffer, PvUInt32 aSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::Attach </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attach this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> to an external memory buffer. </p>
<p>To use an internal memory buffer, use <a class="el" href="class_pv_buffer.html#adaaccc11c6cf44df0a6d6d5fb3e16810" title="Allocates memory for this PvBuffer.">Alloc</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aBuffer</em>&nbsp;</td><td>A pointer to the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aSize</em>&nbsp;</td><td>The size, in bytes, of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#a1fc2ef16100f16a44da2df392d010871" title="A parameter passed to the method is invalid.">PvResult::Code::INVALID_PARAMETER</a></li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_pv_buffer.html#a78b6a8db8a3210b8982ede1d98e4b243" title="Releases an attached memory buffer.">Detach</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a78b6a8db8a3210b8982ede1d98e4b243"></a><!-- doxytag: member="PvBuffer::Detach" ref="a78b6a8db8a3210b8982ede1d98e4b243" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt8 * PvBuffer::Detach </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases an attached memory buffer. </p>
<p>Does nothing other then resetting the memory buffer pointer to NULL.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The buffer's location in memory.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_pv_buffer.html#a72ed401eab17a510c3e420432837e4b7" title="Attach this PvBuffer to an external memory buffer.">Attach</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a897632d211ffca6e730d13f58447d1d9"></a><!-- doxytag: member="PvBuffer::Free" ref="a897632d211ffca6e730d13f58447d1d9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PvBuffer::Free </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees (de-allocates) the buffer's internal memory. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_pv_buffer.html#adaaccc11c6cf44df0a6d6d5fb3e16810" title="Allocates memory for this PvBuffer.">Alloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4adc07be05c831b6a781bceefca920e6"></a><!-- doxytag: member="PvBuffer::GetAcquiredSize" ref="a4adc07be05c831b6a781bceefca920e6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvBuffer::GetAcquiredSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of the payload received by the data receiver. </p>
<p>This attribute is not necessarily equal to (Width * Height * BitsPerPixel) / 8 + (PaddingX * Height + PaddingY) for an image.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The size, in bytes, of bytes received for this buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ab09f72645ff3b6b8ce3c1cbef9cc200b"></a><!-- doxytag: member="PvBuffer::GetBlockID" ref="ab09f72645ff3b6b8ce3c1cbef9cc200b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt64 PvBuffer::GetBlockID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the block ID. </p>
<p>This method returns the block ID. The GigE Vision transmitter typically increments the value by 1 for each new image. You can use this value to ensure the blocks are in order and that none are missing. The value is unsigned and wraps around to 1 (skipping 0) when it reaches 65536.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The block ID </dd></dl>

</div>
</div>
<a class="anchor" id="a8664a7194c866cf60f1c1c00f921c811"></a><!-- doxytag: member="PvBuffer::GetDataPointer" ref="a8664a7194c866cf60f1c1c00f921c811" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt8 * PvBuffer::GetDataPointer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the buffer's data pointer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the memory pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a0646afa2bae0f259f57e3d32b6448f"></a><!-- doxytag: member="PvBuffer::GetDataPointer" ref="a1a0646afa2bae0f259f57e3d32b6448f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const PvUInt8 * PvBuffer::GetDataPointer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the buffer's data pointer. </p>
<p>The <a class="el" href="class_pv_buffer.html#a1a0646afa2bae0f259f57e3d32b6448f" title="Get the buffer&#39;s data pointer.">GetDataPointer</a> method returns a pointer to the buffer. To set the memory location, use <a class="el" href="class_pv_buffer.html#adaaccc11c6cf44df0a6d6d5fb3e16810" title="Allocates memory for this PvBuffer.">Alloc</a> or <a class="el" href="class_pv_buffer.html#a72ed401eab17a510c3e420432837e4b7" title="Attach this PvBuffer to an external memory buffer.">Attach</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the memory pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="acac1f8e6ba0cbd983576e19e970c466c"></a><!-- doxytag: member="PvBuffer::GetID" ref="acac1f8e6ba0cbd983576e19e970c466c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt64 PvBuffer::GetID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the buffer's ID. </p>
<p>See <a class="el" href="class_pv_buffer.html#a49e4f9872d5d1270944c1b8f183b6bde" title="Set the buffer&#39;s ID.">SetID</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The buffer's ID. See <a class="el" href="class_pv_buffer.html#a49e4f9872d5d1270944c1b8f183b6bde" title="Set the buffer&#39;s ID.">SetID</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4a16619899488226618a5b75f432a45"></a><!-- doxytag: member="PvBuffer::GetIgnoredPacketCount" ref="aa4a16619899488226618a5b75f432a45" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvBuffer::GetIgnoredPacketCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packets received that were ignored when this buffer was filled by the data receiver. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The ignored packet count </dd></dl>

</div>
</div>
<a class="anchor" id="ab6b18ddca1320afb60baceebcf0f395d"></a><!-- doxytag: member="PvBuffer::GetImage" ref="ab6b18ddca1320afb60baceebcf0f395d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_pv_image.html">PvImage</a> * PvBuffer::GetImage </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface to the buffer. </p>
<p>Const version.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0e84f98d2c01c33aa6d58343fc242fc"></a><!-- doxytag: member="PvBuffer::GetImage" ref="aa0e84f98d2c01c33aa6d58343fc242fc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_image.html">PvImage</a> * PvBuffer::GetImage </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface to the buffer. </p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> is PvPayloadTypeImage, a pointer to the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface of the buffer is returned.</p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> is NOT PvPayloadTypeImage, a NULL pointer is returned.</p>
<p>This <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> pointer is owned by the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> and does not need to be released after use. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> exists.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a8d3debf9d5bc310701ce87edfff3d4"></a><!-- doxytag: member="PvBuffer::GetLostPacketCount" ref="a2a8d3debf9d5bc310701ce87edfff3d4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvBuffer::GetLostPacketCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packets that were not successfully delivered when this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> was filled by the data receiver. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The lost packet count </dd></dl>

</div>
</div>
<a class="anchor" id="ae3a747cda9952163e0c43dc1d123145b"></a><!-- doxytag: member="PvBuffer::GetMissingPacketIds" ref="ae3a747cda9952163e0c43dc1d123145b" args="(PvUInt32 aIndex, PvUInt32 &amp;aPacketIdLow, PvUInt32 &amp;aPacketIdHigh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::GetMissingPacketIds </td>
          <td>(</td>
          <td class="paramtype">PvUInt32&nbsp;</td>
          <td class="paramname"> <em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt32 &amp;&nbsp;</td>
          <td class="paramname"> <em>aPacketIdLow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PvUInt32 &amp;&nbsp;</td>
          <td class="paramname"> <em>aPacketIdHigh</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a missing packet group that represents an unpopulated area of memory in this buffer. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is an advanced feature that requires knowledge of how GigE Vision data is transmitted. Refer to <a class="el" href="class_pv_buffer.html#a8867f63f913076be52ee0e5add2c9bb3" title="Get the number of missing packet groups that represent unpopulated areas of memory...">GetMissingPacketIdsCount</a> for further details on how this feature is used.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aIndex</em>&nbsp;</td><td>The index of the missing packet group being retrieved. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aPacketIdLow</em>&nbsp;</td><td>The first packet of a range of missing packets. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aPacketIdHigh</em>&nbsp;</td><td>The last packet of a range of missing packets. A value of 0xFFFFFF ( or 0xFFFFFFFF for ExtendedID ) indicates that the last packet of the block went missing and therefore the actual size of the block is unknown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a> or <a class="el" href="struct_pv_result_1_1_code.html#a912d3597af2391488c9e66fd89f22229" title="The requested feature or functionality is not implemented.">PvResult::Code::NOT_IMPLEMENTED</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8867f63f913076be52ee0e5add2c9bb3"></a><!-- doxytag: member="PvBuffer::GetMissingPacketIdsCount" ref="a8867f63f913076be52ee0e5add2c9bb3" args="(PvUInt32 &amp;aCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::GetMissingPacketIdsCount </td>
          <td>(</td>
          <td class="paramtype">PvUInt32 &amp;&nbsp;</td>
          <td class="paramname"> <em>aCount</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of missing packet groups that represent unpopulated areas of memory in this buffer. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is an advanced feature that requires knowledge of how GigE Vision data is transmitted.</dd></dl>
<p>When receiving data from a GigE Vision transmitter, network conditions may prevent the successful delivery of all the data for a given block. Although the eBUS data receiver provides a mechanism for requesting lost packets, there are cases when it is desirable to ignore missing packets and make use of a buffer that contains missing information. In some cases, there are portions of a block that are less important and can thus be disregarded. <a class="el" href="class_pv_buffer.html#a8867f63f913076be52ee0e5add2c9bb3" title="Get the number of missing packet groups that represent unpopulated areas of memory...">GetMissingPacketIdsCount</a> and <a class="el" href="class_pv_buffer.html#ae3a747cda9952163e0c43dc1d123145b" title="Get a missing packet group that represents an unpopulated area of memory in this...">GetMissingPacketIds</a> can provide information about which packets were lost. To use this feature take note of the following procedure:</p>
<ul>
<li>Enable the feature that causes the data receiver to keep track of missing packets (see the <a href="streamparameters.html#EnableMissingPacketsList">EnableMissingPacketsList</a> property of <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision transmitter (data receiver properties dynamically...">PvStream</a>).</li>
<li>Optionally disable the mechanism that requests lost packets (see the <a href="streamparameters.html#RequestMissingPackets">RequestMissingPackets</a> property of <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision transmitter (data receiver properties dynamically...">PvStream</a>).</li>
<li>Check the operation result when a new block is received (see <a class="el" href="class_pv_buffer.html#ab6089cf8573309e856216d0700beecca" title="Returns the value of aOperationResult when this buffer was last received through...">PvBuffer::GetOperationResult</a>).</li>
<li>If the operation result is <a class="el" href="struct_pv_result_1_1_code.html#a684b0f34936b8fd7fe185c02edafd8f8" title="Some packets are missing in the buffer.">PvResult::Code::MISSING_PACKETS</a>, call <a class="el" href="class_pv_buffer.html#a8867f63f913076be52ee0e5add2c9bb3" title="Get the number of missing packet groups that represent unpopulated areas of memory...">GetMissingPacketIdsCount</a> to determine how many groups of packets are missing.</li>
<li>Iterate through the missing packet groups using <a class="el" href="class_pv_buffer.html#ae3a747cda9952163e0c43dc1d123145b" title="Get a missing packet group that represents an unpopulated area of memory in this...">GetMissingPacketIds</a>.</li>
<li>Note that there is no particular order to the missing packet groups that are returned.</li>
<li>Take note of the packet size set on the GigE Vision transmitter from which you are receiving to determine the areas of the payload where information is missing.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>This feature is not available for the legacy eBUS Optimal driver.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aCount</em>&nbsp;</td><td>The number of missing packet groups that represent unpopulated areas of memory in this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a> or <a class="el" href="struct_pv_result_1_1_code.html#a912d3597af2391488c9e66fd89f22229" title="The requested feature or functionality is not implemented.">PvResult::Code::NOT_IMPLEMENTED</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6089cf8573309e856216d0700beecca"></a><!-- doxytag: member="PvBuffer::GetOperationResult" ref="ab6089cf8573309e856216d0700beecca" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::GetOperationResult </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the value of aOperationResult when this buffer was last received through a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision transmitter (data receiver properties dynamically...">PvStream</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of aOperationResult when this buffer was last received through a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision transmitter (data receiver properties dynamically...">PvStream</a>.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_pv_stream_base.html#a3f53879cb4411d122757c99c73e67e3d" title="Attempt to retrieve a queued buffer.">PvStreamBase::RetrieveBuffer</a>, <a class="el" href="class_pv_pipeline.html#a3b18c44b205acc99c2448788c46e4b17" title="Retrieve the next acquired block.">PvPipeline::RetrieveNextBuffer</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a03ff511a9e57369d5c4832bfcca0e2bc"></a><!-- doxytag: member="PvBuffer::GetPacketOutOfOrderCount" ref="a03ff511a9e57369d5c4832bfcca0e2bc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvBuffer::GetPacketOutOfOrderCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of packets received out of order. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The packet out of order count </dd></dl>

</div>
</div>
<a class="anchor" id="adbc6276c6cba843fe2dc994f7d6e1879"></a><!-- doxytag: member="PvBuffer::GetPacketsRecoveredCount" ref="adbc6276c6cba843fe2dc994f7d6e1879" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvBuffer::GetPacketsRecoveredCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of lost packets successfully recovered by packet resend requests. Duplicate received packets are not counted. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The expected resend count </dd></dl>

</div>
</div>
<a class="anchor" id="a6a9fe79913021bfce23d64df1d6b1ce7"></a><!-- doxytag: member="PvBuffer::GetPacketsRecoveredSingleResendCount" ref="a6a9fe79913021bfce23d64df1d6b1ce7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvBuffer::GetPacketsRecoveredSingleResendCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of lost packets successfully recovered by packet resend requests without any resend request retries. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The expected resend count </dd></dl>

</div>
</div>
<a class="anchor" id="af12443f42dd7cc60f6f158cc0b433122"></a><!-- doxytag: member="PvBuffer::GetPayloadType" ref="af12443f42dd7cc60f6f158cc0b433122" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a> PvBuffer::GetPayloadType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the payload type currently used by the buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>PvPayloadType The current payload type for the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a15b8859e0461528b5a8d3be72e722549"></a><!-- doxytag: member="PvBuffer::GetRawData" ref="a15b8859e0461528b5a8d3be72e722549" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_pv_raw_data.html">PvRawData</a> * PvBuffer::GetRawData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer.">PvRawData</a> interface to the buffer. </p>
<p>Const version.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer.">PvRawData</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a class="anchor" id="aeecd2a17dd53ef52ad1873bdb63df1b4"></a><!-- doxytag: member="PvBuffer::GetRawData" ref="aeecd2a17dd53ef52ad1873bdb63df1b4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_raw_data.html">PvRawData</a> * PvBuffer::GetRawData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer.">PvRawData</a> interface to the buffer. </p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> is PvPayloadTypeRawData, a pointer to the <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer.">PvRawData</a> interface of the buffer is returned.</p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> is NOT PvPayloadTypeRawData, a NULL pointer is returned.</p>
<p>This <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer.">PvRawData</a> pointer is owned by the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> and does not need to be released after use. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> exists.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer.">PvRawData</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a class="anchor" id="a9afef8b69586f139a13f51591e3424ca"></a><!-- doxytag: member="PvBuffer::GetRedundantPacketCount" ref="a9afef8b69586f139a13f51591e3424ca" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvBuffer::GetRedundantPacketCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of packets received more than once. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The redundant packet count </dd></dl>

</div>
</div>
<a class="anchor" id="a94ed8b64fbcdd832271eae0d338150e5"></a><!-- doxytag: member="PvBuffer::GetRequiredSize" ref="a94ed8b64fbcdd832271eae0d338150e5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvBuffer::GetRequiredSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of buffer required to hold the acquired block. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The size, in bytes, required to hold the block in this buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a2aab5ebb5e9c3c6b6062134973c4db4b"></a><!-- doxytag: member="PvBuffer::GetResendGroupRequestedCount" ref="a2aab5ebb5e9c3c6b6062134973c4db4b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvBuffer::GetResendGroupRequestedCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of resend requests issued by the data receiver. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The resend requested count </dd></dl>

</div>
</div>
<a class="anchor" id="a521d00b4ae59ecfb38476f8aa24e9c65"></a><!-- doxytag: member="PvBuffer::GetResendPacketRequestedCount" ref="a521d00b4ae59ecfb38476f8aa24e9c65" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvBuffer::GetResendPacketRequestedCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of packets the data receiver requests with ResendGroupRequested. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The received resend requested packet count </dd></dl>

</div>
</div>
<a class="anchor" id="a73d5467e8e1e198a7268e432ab22bf16"></a><!-- doxytag: member="PvBuffer::GetSize" ref="a73d5467e8e1e198a7268e432ab22bf16" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt32 PvBuffer::GetSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the buffer's size (total capacity) in bytes. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The buffer's (allocated or attached) size in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a7cf2ba1ca5d1978ea1098cf150dacd17"></a><!-- doxytag: member="PvBuffer::GetTimestamp" ref="a7cf2ba1ca5d1978ea1098cf150dacd17" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvUInt64 PvBuffer::GetTimestamp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the buffer's timestamp. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The buffer's hardware timestamp; For Pleora GigE Vision devices, this is the value of the <b>GevTimestampValue</b> when it began receiving data from the camera head (on the rising edge of the FVAL). </dd></dl>

</div>
</div>
<a class="anchor" id="afb764127bb8864f866ef812cd2dc1e61"></a><!-- doxytag: member="PvBuffer::IsExtendedID" ref="afb764127bb8864f866ef812cd2dc1e61" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvBuffer::IsExtendedID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the buffer is currently in extended ID mode. </p>
<p>When the extended ID mode is not enabled, the maximum block ID is 0xFFFFFF and the maximum packet ID is 0xFFFFFF as per the GEV 1.X specification. When the extended ID mode is enabled, the maximum block ID is 0xFFFFFFFFFFFFFFFF and the maximum packet ID is 0xFFFFFFFF as per the GEV 2.X specification.</p>
<p>When a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> is received, the extended ID mode is initialized based on the information received by <a class="el" href="class_pv_stream_base.html" title="Base class defining functionality inherited by PvStream and PvStreamRaw.">PvStreamBase</a>. When a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision data in memory.">PvBuffer</a> is sent, the extended ID mode will be initialized by the <a class="el" href="class_pv_transmitter_raw.html#abb010fd9763909b21144b0d43769e64a" title="Constructor.">PvTransmitterRaw::PvTransmitterRaw</a> according to its configuration.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the extended if mode is in usage: </dd></dl>

</div>
</div>
<a class="anchor" id="afedeb78adc823aff996d5682f4fdeac0"></a><!-- doxytag: member="PvBuffer::IsHeaderValid" ref="afedeb78adc823aff996d5682f4fdeac0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvBuffer::IsHeaderValid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether this buffer has valid header (GVSP) information. </p>
<p>If the buffer header is not valid (missing) the buffer has to be manipulated with extreme caution. To start with, it is impossible to confirm the payload type. The timestamp and other shared header information is not valid. Finally, information specific to some payload types (like with, height, pixel format, etc. for the image payload type) is not available or valid this buffer.</p>
<p>When a buffer is attached or allocated for use other than receiving GVSP data, this attribute evaluates to true in order to appear as valid.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the GVSP header is valid. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c7d71796bff6856871b1d6468a1f2df"></a><!-- doxytag: member="PvBuffer::IsTrailerValid" ref="a3c7d71796bff6856871b1d6468a1f2df" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvBuffer::IsTrailerValid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether this buffer has valid trailer (GVSP) information. </p>
<p>If the buffer trailer is not valid (missing) some information about the buffer could be missing. As an example, the image payload type confirms the number of lines received in the trailer.</p>
<p>When a buffer is attached or allocated for use other than receiving GVSP data, this attribute evaluates to true in order to appear as valid.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the GVSP header is valid. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ec5abd18467aa4855a6ba46e22c6b02"></a><!-- doxytag: member="PvBuffer::Reset" ref="a1ec5abd18467aa4855a6ba46e22c6b02" args="(PvPayloadType aPayloadType=PvPayloadTypeImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a>&nbsp;</td>
          <td class="paramname"> <em>aPayloadType</em> = <code>PvPayloadTypeImage</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reconstruct the object with a new payload type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aPayloadType</em>&nbsp;</td><td>The payload type to reset the buffer to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a> if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a49e4f9872d5d1270944c1b8f183b6bde"></a><!-- doxytag: member="PvBuffer::SetID" ref="a49e4f9872d5d1270944c1b8f183b6bde" args="(PvUInt64 aValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PvBuffer::SetID </td>
          <td>(</td>
          <td class="paramtype">PvUInt64&nbsp;</td>
          <td class="paramname"> <em>aID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the buffer's ID. </p>
<p>The <a class="el" href="class_pv_buffer.html#a49e4f9872d5d1270944c1b8f183b6bde" title="Set the buffer&#39;s ID.">SetID</a> method lets you assign an arbitrary number to a buffer. When you retrieve the buffer later, you can also recover the number you assigned.</p>
<p>The ID is completely arbitrary and solely available for your own use. It can be useful to keep track of buffers in an application.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aID</em>&nbsp;</td><td>The buffer's ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6c2e9572443c6969f2b1e45ea30829f"></a><!-- doxytag: member="PvBuffer::SetTimestamp" ref="af6c2e9572443c6969f2b1e45ea30829f" args="(PvUInt64 aTimestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::SetTimestamp </td>
          <td>(</td>
          <td class="paramtype">PvUInt64&nbsp;</td>
          <td class="paramname"> <em>aTimestamp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the timestamp to place in the block leader. </p>
<p>When transmitting blocks to a GigE Vision receiver, by default, the timestamp on outgoing blocks is zero. However, the calling application may set a timestamp on the outgoing blocks if desired by calling <a class="el" href="class_pv_buffer.html#af6c2e9572443c6969f2b1e45ea30829f" title="Set the timestamp to place in the block leader.">SetTimestamp</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTimestamp</em>&nbsp;</td><td>The timestamp to set in the block leader</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="struct_pv_result_1_1_code.html#ab102fe79d528c7f87d3b5abbfb595829" title="Success! (Immediate.).">PvResult::Code::OK</a> if successful. </dd></dl>

</div>
</div>
</div>
<hr size="1">
<P><B>Copyright (c) 2002-2012 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>

