<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>eBUS SDK C++ API: Stream Parameters Stream Parameters</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>

	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v3.0.4.2568 C++ API</h2>
		</div>
	</div>
		
		<br>
		<br>

	</body>
	
</html>


<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="streamparameters">Stream Parameters Stream Parameters </a></h1> <style type="text/css"> table.layout {  border-width: thin;  border-spacing: 0px;  border-style: solid;  border-color: black;  border-collapse: collapse;  background-color: white; } table.layout th {  border-width: thin;  padding: 3px;  border-style: inset;  border-color: black;  background-color: white;  -moz-border-radius: ; } table.layout td {  border-width: thin;  padding: 3px;  border-style: inset;  border-color: black;  background-color: white;  -moz-border-radius: ; } </style> <br/>
 </p>
<h2>Category: Root/Configuration </h2>
<p><br/>
 </p>
<table class="layout" border="1" cellspacing="3" cellpadding="3">
<tr valign="top" align="left">
<th width="20%"><p>Parameter </p>
</th><th width="50%"><p>Description </p>
</th><th width="20%"><p>Additional Information </p>
</th><th width="10%"><p>Visibility  </p>
</th></tr>
<tr id="FirstPacketTimeout" valign="top" align="left">
<td><p>FirstPacketTimeout </p>
</td><td><p>The maximum time (in milliseconds) the data receiver waits for the first packet of a block. This timer starts when the first packet of the stream is received. sA value of zero (default) implies different behaviour depending on the driver being used. sFor the Manufacturer driver and the eBUS Universal Pro driver a value of zero implies that no first packet timeout will be enforced.sFor the eBUS Optimal driver a value of zero indicates that the timeout is automatically computed based on the request timeout and the packet size. sUpon expiry of this timer, the buffer is returned with an operation result describing the error . </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="PacketTimeout" valign="top" align="left">
<td><p>PacketTimeout </p>
</td><td><p>Only available for legacy eBUS drivers (eBUS Universal and eBUS Optimal).sThe maximum time (in milliseconds) that the data receiver waits for the second and subsequent packets of a requested block. A value of zero indicates that the timeout is automatically computed from the FirstPacketTimeout parameter. Upon expiry of this timer, the buffer is returned with an operation result describing the error. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="InterPacketTimeout" valign="top" align="left">
<td><p>InterPacketTimeout </p>
</td><td><p>The maximum time (in milliseconds) to wait in between two packets of a block. If set to 0, no maximum inter packet timeout is enforced. Upon expiry of this timer, the buffer is returned with an operation result describing the error. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="RequestTimeout" valign="top" align="left">
<td><p>RequestTimeout </p>
</td><td><p>The maximum time (in milliseconds) that the data receiver waits for all the packets of a block. Upon expiry of this timer, the buffer is returned with an operation result describing the error. For the Manufacturer driver and the eBUS Universal Pro driver, this timer starts when the first packet of the stream is received. For legacy drivers this timer starts when the first buffer is queued . </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="PreemptiveResendTimeout" valign="top" align="left">
<td><p>PreemptiveResendTimeout </p>
</td><td><p>The time (in milliseconds) the data receiver waits for the a packet of the most recent block becore making a resend request when no activity is detected.If set to 0, no preemptive resend will be done. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="MaximumPendingResends" valign="top" align="left">
<td><p>MaximumPendingResends </p>
</td><td><p>Maximum number of packets in a block that can be missing, at any one time, before the buffer is returned with an operation result describing the error. A value of zero indicates that there is no limit to the number of pending resend requests. </p>
</td><td><p>Unsigned 64 bits integer<br/>
Max: 4096 </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="RequestMissingPackets" valign="top" align="left">
<td><p>RequestMissingPackets </p>
</td><td><p>If enabled, missing packets are requested. Other parameters that control the resend request behaviour include MaximumResendRequestRetryByPacket, MaximumResendGroupSize, ResendRequestTimeout, MaximumPendingResends and ResendDelay. </p>
</td><td><p>Boolean </p>
</td><td><p>Beginner </p>
</td></tr>
<tr id="LatencyLevel" valign="top" align="left">
<td><p>LatencyLevel </p>
</td><td><p>Only available when receiving data through the eBUS Universal Pro driver for windows.sThis value allows the tuning of the driver to modify the acceptable amount of latency at the cost of using greater CPU resources. A value of 0 minimizes latency as much as possible. </p>
</td><td><p>Unsigned 64 bits integer<br/>
Max: 3 </p>
</td><td><p>Guru  </p>
</td></tr>
<tr id="AutoResetOnLackOfResources" valign="top" align="left">
<td><p>AutoResetOnLackOfResources </p>
</td><td><p>The threshold of buffers available to be filled in the data receiver. When the number of buffers available to be filled is less than this threshold, all incomplete buffers are returned with an operation result describing the error. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Expert  </p>
</td></tr>
<tr id="MaximumResendRequestRetryByPacket" valign="top" align="left">
<td><p>MaximumResendRequestRetryByPacket </p>
</td><td><p>The maximum number of times a resend request can be issued before the buffer is returned with an operation result describing the error. A value of zero indicates that there is no limit on the number of resend requests. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Guru  </p>
</td></tr>
<tr id="MaximumResendGroupSize" valign="top" align="left">
<td><p>MaximumResendGroupSize </p>
</td><td><p>GigE Vision allows for a single resend request to contain requests for 1 or more packets. This parameter defines the maximum number of packets that can be requested at one time. A value of zero indicates that there is no limit to the resend group size. If the number of consecutive missing packets is larger than this value, the operation result is set to TOO_MANY_CONSECUTIVE_RESENDS. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Guru  </p>
</td></tr>
<tr id="ResendRequestTimeout" valign="top" align="left">
<td><p>ResendRequestTimeout </p>
</td><td><p>The amount of time (in milliseconds) the data receiver waits for a response to a resend request before issuing the request again. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Guru  </p>
</td></tr>
<tr id="ResendDelay" valign="top" align="left">
<td><p>ResendDelay </p>
</td><td><p>Time (in microseconds) to wait before issuing a resend request for a missing packet.  </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Guru  </p>
</td></tr>
<tr id="ResetOnIdle" valign="top" align="left">
<td><p>ResetOnIdle </p>
</td><td><p>This parameter defines the time that the data receiver waits for while there is no GVSP packet coming before resetting itself.sOn a reset, 1) All the Receiving block buffers to Ready for Processing states with error code AUTO_ABORTED. All Empty block buffers are still in the data receiver and ready for receiving. 2) The data receiver goes back to the pre stream start status.sThis parameter allows the data receiver to better handle the cases where the data receiver receives no packets for a long time due to a connection loss or a large number of packets are dropped on the network. Without this parameter, the data receiver may not be able to recover quickly as it may try to request many packets resends. sThis parameter also can help the data receiver work properly in the situation that the application is only a data receiver and the transmitter resets the block_id. For example, the transmitter transmitted the block_id n and data receiver received it. Then data receiver is excepting block_id n+1 but if the transmitter resets the block_id to 1. Without this parameter to reset it back to the pre stream start status the data receiver will ignore the new coming in blocks until it receives block_id n+1. For some transmitter devices, acquisition stop and start resets the block_id to 1. For a software transmitter, for instance Pleora Video server, after you call <a class="el" href="class_pv_transmitter_raw.html#a544877d11e8499a35995cad8f4ec47e2" title="Stop sending data and close the socket.">PvTransmitterRaw::Close()</a> and then <a class="el" href="class_pv_transmitter_raw.html#abd14a57d5220bc0f679fc140c53a8806" title="Initialize a socket to begin transmitting data.">PvTransmitterRaw::Open()</a> then the block_id resets to 1. In both cases if the stream destination IP address and port remain same as before then the data receiver application still receives those blocks. Data receiver could not tell if those block data are from new coming block data or the packet resend for the same block_id which has been received before. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Guru  </p>
</td></tr>
<tr id="ForceMissingPacketsAtNextBlockStart" valign="top" align="left">
<td><p>ForceMissingPacketsAtNextBlockStart </p>
</td><td><p>Forces the data receiver to stop waiting for packets from a block in the event that packets begin to arrive from the next block. </p>
</td><td><p>Boolean </p>
</td><td><p>Guru </p>
</td></tr>
<tr id="EnableMissingPacketsList" valign="top" align="left">
<td><p>EnableMissingPacketsList </p>
</td><td><p>Enables the data receiver to keep track of packets that were lost while attempting to receive a block. Enable if you plan on using <a class="el" href="class_pv_buffer.html#a8867f63f913076be52ee0e5add2c9bb3" title="Get the number of missing packet groups that represent unpopulated areas of memory...">PvBuffer::GetMissingPacketIdsCount</a> and <a class="el" href="class_pv_buffer.html#ae3a747cda9952163e0c43dc1d123145b" title="Get a missing packet group that represents an unpopulated area of memory in this...">PvBuffer::GetMissingPacketIds</a> . </p>
</td><td><p>Boolean </p>
</td><td><p>Guru </p>
</td></tr>
<tr id="MaximumPreQueuedBuffers" valign="top" align="left">
<td><p>MaximumPreQueuedBuffers </p>
</td><td><p>Only available when receiving data through the eBUS Universal Pro driver.sNumber of buffers queued before passing the buffers between user space and kernel space. Increasing this number reduces the number of times data is exchanged between the SDK in user space and the driver in kernel space. This can increase performance in the case where data is being streamed at high frame rates. Before using this parameter, ensure that a sufficient number of buffers queued into the stream. </p>
</td><td><p>Unsigned 64 bits integer<br/>
Min: 1<br/>
Max: 32 </p>
</td><td><p>Guru  </p>
</td></tr>
</table>
<p><br/>
 </p>
<h2>Category: Root/Connection </h2>
<p><br/>
 </p>
<table class="layout" border="1" cellspacing="3" cellpadding="3">
<tr valign="top" align="left">
<th width="20%"><p>Parameter </p>
</th><th width="50%"><p>Description </p>
</th><th width="20%"><p>Additional Information </p>
</th><th width="10%"><p>Visibility  </p>
</th></tr>
<tr id="DataPort" valign="top" align="left">
<td><p>DataPort </p>
</td><td><p>UDP port to which the GigE Vision transmitter should send data. For unicast data, this is the local (PC side) port number. For multicast data, this is the port number to which the receiver is subscribed. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="MulticastIPAddress" valign="top" align="left">
<td><p>MulticastIPAddress </p>
</td><td><p>Address of the multicast group, if applicable. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="LocalIPAddress" valign="top" align="left">
<td><p>LocalIPAddress </p>
</td><td><p>Local IP address used to receive data from the GigE Vision transmitter. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="DeviceIPAddress" valign="top" align="left">
<td><p>DeviceIPAddress </p>
</td><td><p>IP address of the GigE Vision transmitter from which the stream is receiving data. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="ChannelID" valign="top" align="left">
<td><p>ChannelID </p>
</td><td><p>The GigE Vision streaming channel from which to receive. Use the GevStreamChannelSelector transport layer feature of your GigE Vision device to specify the channel you wish to control. Use the GevStreamChannelCount transport layer feature of your GigE Vision device to determine the number of channels it supports. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
</table>
<p><br/>
 </p>
<h2>Category: Root/General </h2>
<p><br/>
 </p>
<table class="layout" border="1" cellspacing="3" cellpadding="3">
<tr valign="top" align="left">
<th width="20%"><p>Parameter </p>
</th><th width="50%"><p>Description </p>
</th><th width="20%"><p>Additional Information </p>
</th><th width="10%"><p>Visibility  </p>
</th></tr>
<tr id="BitsCount" valign="top" align="left">
<td><p>BitsCount </p>
</td><td><p>Number of data payload bits received by the stream. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="BytesCount" valign="top" align="left">
<td><p>BytesCount </p>
</td><td><p>Number of data payload bytes received by the stream. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="BlockCount" valign="top" align="left">
<td><p>BlockCount </p>
</td><td><p>Number of blocks received from the device. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="SamplingTime" valign="top" align="left">
<td><p>SamplingTime </p>
</td><td><p>The time elapsed (in ms) between the first block received and the latest block received. Note the definition of the first block in this case would be the first block received after having either opening the stream or issuing the Reset command. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="AcquisitionRate" valign="top" align="left">
<td><p>AcquisitionRate </p>
</td><td><p>Instant acquisition rate. </p>
</td><td><p>Float </p>
</td><td><p>Beginner </p>
</td></tr>
<tr id="AcquisitionRateAverage" valign="top" align="left">
<td><p>AcquisitionRateAverage </p>
</td><td><p>Average acquisition rate since the first block was received. </p>
</td><td><p>Float </p>
</td><td><p>Beginner </p>
</td></tr>
<tr id="Bandwidth" valign="top" align="left">
<td><p>Bandwidth </p>
</td><td><p>Instant throughput in bits per second. Note that this value is calculated based on a finite sequence of received blocks within a finite period of time. </p>
</td><td><p>Float </p>
</td><td><p>Beginner </p>
</td></tr>
<tr id="BandwidthAverage" valign="top" align="left">
<td><p>BandwidthAverage </p>
</td><td><p>Average throughput since the last reset in bits per second. </p>
</td><td><p>Float </p>
</td><td><p>Beginner </p>
</td></tr>
<tr id="TimeoutCountedAsError" valign="top" align="left">
<td><p>TimeoutCountedAsError </p>
</td><td><p>When enabled, timeouts are considered errors. Depending on the nature and behavior of an application, timeouts can be normal occurrences or represent real errors. </p>
</td><td><p>Boolean </p>
</td><td><p>Guru </p>
</td></tr>
<tr id="AbortCountedAsError" valign="top" align="left">
<td><p>AbortCountedAsError </p>
</td><td><p>When enabled, aborted buffers are considered errors. Depending on the nature and behavior of an application, aborted buffers can be normal occurrences or represent real errors. </p>
</td><td><p>Boolean </p>
</td><td><p>Guru </p>
</td></tr>
<tr id="ErrorCount" valign="top" align="left">
<td><p>ErrorCount </p>
</td><td><p>Count of RetrieveBuffer operation result errors since the last reset. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="LastError" valign="top" align="left">
<td><p>LastError </p>
</td><td><p>Last RetrieveBuffer operation result error. </p>
</td><td><p>Enumeration.<br/>
Entries: None,<br/>
NOT_INITIALIZED,<br/>
NOT_FOUND,<br/>
CANNOT_OPEN_FILE,<br/>
NO_MORE_ITEM,<br/>
NOT_CONNECTED,<br/>
STATE_ERROR,<br/>
THREAD_ERROR,<br/>
INVALID_DATA_FORMAT,<br/>
ABORTED,<br/>
NOT_ENOUGH_MEMORY,<br/>
GENERIC_ERROR,<br/>
INVALID_PARAMETER,<br/>
CANCEL,<br/>
PENDING,<br/>
TIMEOUT,<br/>
NO_LICENSE,<br/>
GENICAM_XML_ERROR,<br/>
NOT_IMPLEMENTED,<br/>
NOT_SUPPORTED,<br/>
FILE_ERROR,<br/>
ERR_OVERFLOW,<br/>
IMAGE_ERROR,<br/>
MISSING_PACKETS,<br/>
BUFFER_TOO_SMALL,<br/>
TOO_MANY_RESENDS,<br/>
RESENDS_FAILURE,<br/>
TOO_MANY_CONSECUTIVE_RESENDS,<br/>
AUTO_ABORTED,<br/>
BAD_VERSION,<br/>
NO_MORE_ENTRY,<br/>
NO_AVAILABLE_DATA,<br/>
NETWORK_ERROR </p>
</td><td><p>Beginner </p>
</td></tr>
<tr id="TimestampSourceEffective" valign="top" align="left">
<td><p>TimestampSourceEffective </p>
</td><td><p>Source of the buffer timestamps in use. Hardware refers to the device timestamp present in the GVSP header. Software refers to host-side timestamps recorded when a buffer is delivered by the data receiver. </p>
</td><td><p>Enumeration.<br/>
Entries: Hardware,<br/>
Software </p>
</td><td><p>Guru </p>
</td></tr>
<tr id="TimestampSourcePreferred" valign="top" align="left">
<td><p>TimestampSourcePreferred </p>
</td><td><p>Preferred source of the buffer timestamps used to track statistics. Hardware refers to the device timestamp present in the GVSP header. Software refers to host-side timestamps recorded when a buffer is delivered by the data receiver. </p>
</td><td><p>Enumeration.<br/>
Entries: Hardware,<br/>
Software </p>
</td><td><p>Guru </p>
</td></tr>
</table>
<p><br/>
 </p>
<h2>Category: Root/Counters </h2>
<p><br/>
 </p>
<table class="layout" border="1" cellspacing="3" cellpadding="3">
<tr valign="top" align="left">
<th width="20%"><p>Parameter </p>
</th><th width="50%"><p>Description </p>
</th><th width="20%"><p>Additional Information </p>
</th><th width="10%"><p>Visibility  </p>
</th></tr>
<tr id="BlockIDsMissing" valign="top" align="left">
<td><p>BlockIDsMissing </p>
</td><td><p>The number of missing block IDs. sCalculated using the block ID of incoming blocks to count blocks sent by the GigE Vision device that were not successfully delivered. This is typically caused by the application not being able to de-queue and re-queue buffers quickly enough. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="PipelineBlocksDropped" valign="top" align="left">
<td><p>PipelineBlocksDropped </p>
</td><td><p>This provides a count of blocks dropped by the <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision transmitter.">PvPipeline</a>. The oldest blocks are dropped from the <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision transmitter.">PvPipeline</a> output queue if it runs out of resources. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
</table>
<p><br/>
 </p>
<h2>Category: Root/DataReceiver </h2>
<p><br/>
 </p>
<table class="layout" border="1" cellspacing="3" cellpadding="3">
<tr valign="top" align="left">
<th width="20%"><p>Parameter </p>
</th><th width="50%"><p>Description </p>
</th><th width="20%"><p>Additional Information </p>
</th><th width="10%"><p>Visibility  </p>
</th></tr>
<tr id="PacketsRecovered" valign="top" align="left">
<td><p>PacketsRecovered </p>
</td><td><p>The number of lost packets successfully recovered by packet resend requests. Duplicate received packets are not counted. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="PacketsRecoveredSingleResend" valign="top" align="left">
<td><p>PacketsRecoveredSingleResend </p>
</td><td><p>The number of lost packets successfully recovered by packet resend requests without any resend request retries. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="UnexpectedResend" valign="top" align="left">
<td><p>UnexpectedResend </p>
</td><td><p>Unexpected resent packet count. This includes packets received multiple times for a buffer and packets received before a buffer has been completed. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="ResendGroupRequested" valign="top" align="left">
<td><p>ResendGroupRequested </p>
</td><td><p>The number of resend requests issued by the data receiver </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="ResendPacketRequested" valign="top" align="left">
<td><p>ResendPacketRequested </p>
</td><td><p>The number of packets the data receiver requests with ResendGroupRequested. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="LostPacket" valign="top" align="left">
<td><p>LostPacket </p>
</td><td><p>Lost packet count. This counter tracks the number of expected packets that were not received. This counter does not include the packet count of missing blocks. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="IgnoredPacket" valign="top" align="left">
<td><p>IgnoredPacket </p>
</td><td><p>The number of packets received that are not related to the current set of blocks being processed. This includes packets with block ids that have already been processed. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="RedundantPacket" valign="top" align="left">
<td><p>RedundantPacket </p>
</td><td><p>Number of packets received more than once </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="PacketOutOfOrder" valign="top" align="left">
<td><p>PacketOutOfOrder </p>
</td><td><p>Number of packets received out of order </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
</table>
<p><br/>
 </p>
<h2>Category: Root/Status </h2>
<p><br/>
 </p>
<table class="layout" border="1" cellspacing="3" cellpadding="3">
<tr valign="top" align="left">
<th width="20%"><p>Parameter </p>
</th><th width="50%"><p>Description </p>
</th><th width="20%"><p>Additional Information </p>
</th><th width="10%"><p>Visibility  </p>
</th></tr>
<tr id="DataOverrun" valign="top" align="left">
<td><p>DataOverrun </p>
</td><td><p>Count of data overrun notifications received from the device. A data overrun notification is sent when the incoming (from a sensor) data rate exceeds the device's data capture rate. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="PartialLineMissing" valign="top" align="left">
<td><p>PartialLineMissing </p>
</td><td><p>Count of images that have at least one partial line missing. Only available for devices using a Pleora IP engine.  </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="FullLineMissing" valign="top" align="left">
<td><p>FullLineMissing </p>
</td><td><p>Count of images that have at least on full line missing. Only available for devices using a Pleora IP engine. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="BlocksDropped" valign="top" align="left">
<td><p>BlocksDropped </p>
</td><td><p>Count of dropped block notifications received from the device. Dropped block notifications are sent when the frame buffer is full and the incoming data cannot be processed. Only available for devices using a Pleora IP engine. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="EOFByLineCount" valign="top" align="left">
<td><p>EOFByLineCount </p>
</td><td><p>Count of frames where the previous frame was NOT the last one of a sequence of sub frames but the line count was met. Only available for devices using a Pleora IP engine. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="InterlacedEven" valign="top" align="left">
<td><p>InterlacedEven </p>
</td><td><p>Count of interlaced even fields from an interlaced image. Only for devices using a Pleora IP engine. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="InterlacedOdd" valign="top" align="left">
<td><p>InterlacedOdd </p>
</td><td><p>Count of interlaced odd fields from an interlaced image. Only for devices using a Pleora IP engine. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="LocalProblem" valign="top" align="left">
<td><p>LocalProblem </p>
</td><td><p>Count of "Local Problem" status notifications received from the device. An internal problem in the device implementation occurred while processing the request. Optionally the device provides a mechanism for looking up a detailed description of the problem. (Log files, Event log, 'Get last error' mechanics). This error is intended to report problems from underlying services (operating system, 3rd party library) in the device to the client side without translating every possible error code into a GigE Vision equivalent. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="Unknown" valign="top" align="left">
<td><p>Unknown </p>
</td><td><p>Count of status notifications received from the device not mapping to a known value. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="PacketUnavailable" valign="top" align="left">
<td><p>PacketUnavailable </p>
</td><td><p>Count of "Packet Unavailable" status notifications received from the device. The device returns this status notification when a packet is requested but is no longer available. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
</table>
<p><br/>
 </p>
<h2>Category: Root/Errors </h2>
<p><br/>
 </p>
<table class="layout" border="1" cellspacing="3" cellpadding="3">
<tr valign="top" align="left">
<th width="20%"><p>Parameter </p>
</th><th width="50%"><p>Description </p>
</th><th width="20%"><p>Additional Information </p>
</th><th width="10%"><p>Visibility  </p>
</th></tr>
<tr id="ResultImageError" valign="top" align="left">
<td><p>ResultImageError </p>
</td><td><p>Count of failed buffers with operation result set to IMAGE_ERROR. Incremented when a corrupt image arrives due to discontinuities in data between the camera and the hardware responsible for transmitting packets in the GigE Vision device. This can include data overrun, partial and full lines missing. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="ResultMissingPackets" valign="top" align="left">
<td><p>ResultMissingPackets </p>
</td><td><p>Count of failed buffers with operation result set to MISSING_PACKETS. Happens when at least one packet of the buffer is missing when it was released back to the calling application. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="ResultBufferTooSmall" valign="top" align="left">
<td><p>ResultBufferTooSmall </p>
</td><td><p>Count of failed buffers with operation result set to BUFFER_TOO_SMALL. Happens when a buffer queued for streaming was not large enough to contain the received payload.  </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="ResultTimeout" valign="top" align="left">
<td><p>ResultTimeout </p>
</td><td><p>Count of failed buffers with operation result set to TIMEOUT. This happens when FirstPacketTimeout has elapsed without receiving any packets or when RequestTimeout has elapsed after receiving the first packet for the buffer. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="ResultAborted" valign="top" align="left">
<td><p>ResultAborted </p>
</td><td><p>Count of failed buffers with operation result set to ABORTED. After calling AbortQueuedBuffers all buffers in the stream are completed with the ABORTED operation result. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="ResultAutoAborted" valign="top" align="left">
<td><p>ResultAutoAborted </p>
</td><td><p>Count of failed buffers with operation result set to AUTO_ABORTED. The data receiver may enter a state where packets arrive for a newer block while one or more packets for an older block are still missing. The AutoResetOnLackOfResources parameter is the threshold of free buffers maintained by the data receiver. If a packet arrives for a new block and only AutoResetOnLackOfResources buffers are currently available then all incomplete buffers that have not yet finished being filled are immediately returned with result code AUTO_ABORTED. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="ResultStateError" valign="top" align="left">
<td><p>ResultStateError </p>
</td><td><p>Count of failed buffers with operation result set to STATE_ERROR. The data receiver experienced an internal error while attempting to receive this buffer. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="ResultInvalidDataFormat" valign="top" align="left">
<td><p>ResultInvalidDataFormat </p>
</td><td><p>Count of failed buffers with operation result set to INVALID_DATA_FORMAT. Poorly formatted data was received from the GigE Vision transmitter. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="ResultTooManyResends" valign="top" align="left">
<td><p>ResultTooManyResends </p>
</td><td><p>Count of failed buffers with operation result set to TOO_MANY_RESENDS. The data receiver stops attempting to receive a block if too many packet resends were issued. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="ResultTooManyConsecutiveResends" valign="top" align="left">
<td><p>ResultTooManyConsecutiveResends </p>
</td><td><p>Count of failed buffers with operation result set to TOO_MANY_CONSECUTIVE_RESENDS. The data receiver stops attempting to receive a block if a set of consecutive lost packets exceeds MaximumResendGroupSize. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="ResultResendsFailure" valign="top" align="left">
<td><p>ResultResendsFailure </p>
</td><td><p>Count of failed buffers with operation result set to RESENDS_FAILURE. The data receiver has attempted to recover missing packets by issuing resend requests. The maximum number of retries has been reached without having received the requested packet. The MaximumResendRequestRetryByPacket property can be used to configure how many times the data receiver re-attempts a request for a lost packet.  </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
<tr id="ResultNotInitialized" valign="top" align="left">
<td><p>ResultNotInitialized </p>
</td><td><p>Count of buffers with an operational state that is not initialized.sThis operational result is used when ForceMissingPacketsAtNextBlockStart is enabled. The buffer used by the current block is skipped because of a missing block and the operational result of the buffer is set to not initialized. This means nothing in the buffer is valid. </p>
</td><td><p>Unbound unsigned 64 bits integer </p>
</td><td><p>Beginner  </p>
</td></tr>
</table>
</div>
<hr size="1">
<P><B>Copyright (c) 2002-2012 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>

